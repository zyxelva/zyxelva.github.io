<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="【Redis学习】5.高可用之集群, Back-End Dev Java"><meta name="description" content="1 前言主从复制实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。但是缺陷也很突出：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
而哨兵模式，在复制的基础上，实现了自动化的故障恢复。缺陷有：写操作无法负载均"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>【Redis学习】5.高可用之集群 | Kezade</title><link rel="icon" type="image/jpeg" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg"><style>body{background-image:url(https://it-ark-dev.oss-cn-shenzhen.aliyuncs.com/464e9ac7a5a729ae67f91f7cf0cf6fe2.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:cover;background-position:center center}</style><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/animate/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.1/css/matery.css?v3"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/my.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/post.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/reward.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/jquery/jquery-3.6.0.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.3/js/function.js?v88"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/imgStatus.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/waterfall.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/lately.min.js"></script><script>var memos={host:"https://s.dusays.com/",limit:"10",creatorId:"49",username:"zyxelva",name:"Kezade",domId:"#memos",path:"api/v1/memo"},douban={api:"https://douban-api.edui.fun/"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="Kezade" type="application/rss+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img k-avatar" alt="LOGO"> <span class="logo-span">Kezade</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-newspaper" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:0.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-sitemap" style="zoom:0.6"></i> <span>系列</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/categories/%E7%AE%97%E6%B3%95"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>考研</span></a></li><li><a href="/categories/OSSD"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>高考</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-place-of-worship" style="zoom:0.6"></i> <span>我的</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:0.6"></i> <span>相册</span></a></li><li><a href="/bibi"><i class="fa-fw fa-solid fa-cloud-rain" style="margin-top:-20px;zoom:0.6"></i> <span>哔哔</span></a></li><li><a href="/todolist"><i class="fa-fw fa-solid fa-circle-check" style="margin-top:-20px;zoom:0.6"></i> <span>清单</span></a></li><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:0.6"></i> <span>音乐</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-circle-info" style="zoom:0.6"></i> <span>更多</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:0.6"></i> <span>留言</span></a></li><li><a href="/friends"><i class="fa-solid fa-link" style="margin-top:-20px;zoom:0.6"></i> <span>友链</span></a></li><li><a href="/friend-circle"><i class="fa-solid fa-rss" style="margin-top:-20px;zoom:0.6"></i> <span>圈圈</span></a></li><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:0.6"></i> <span>关于</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img circle responsive-img"><div class="logo-name">Kezade</div><div class="logo-desc">7 年 Java 开发经验，其中 3 年以上大型系统架构设计经验，以及 2 年以上的团队管理经验 | 具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验 | 对 Zookeeper、Netty、Dubbo、Spring Cloud、 Spring 等开源框架源码有过深入研究，并且有一定的框架定制开发经验</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-newspaper"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-sitemap"></i> 系列<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/categories/%E7%AE%97%E6%B3%95" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>考研</span></a></li><li><a href="/categories/OSSD" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>高考</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-place-of-worship"></i> 我的<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/bibi" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-cloud-rain" style="position:absolute;left:50px"></i> <span>哔哔</span></a></li><li><a href="/todolist" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-circle-check" style="position:absolute;left:50px"></i> <span>清单</span></a></li><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-circle-info"></i> 更多<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="/friends" style="margin-left:75px"><i class="fa fa-solid fa-link" style="position:absolute;left:50px"></i> <span>友链</span></a></li><li><a href="/friend-circle" style="margin-left:75px"><i class="fa fa-solid fa-rss" style="position:absolute;left:50px"></i> <span>圈圈</span></a></li><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/cryptojs/crypto-js.min.js"></script><script></script><style>:root{--post-bg-image:url('https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/featureimages/13.jpg')}</style><div class="bg-cover pd-header post-cover"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">【Redis学习】5.高可用之集群</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a> <a href="/tags/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"><span class="chip bg-color">集群模式</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis%E5%AD%A6%E4%B9%A0/" class="post-category">Redis学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-08-30</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 8.2k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 29 分</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p><code>主从复制</code>实现了数据的多机备份，以及对于<code>读操作的负载均衡</code>和<code>简单的故障恢复</code>。但是<code>缺陷</code>也很突出：<strong>故障恢复无法自动化</strong>；<strong>写操作无法负载均衡</strong>；<strong>存储能力受到单机的限制</strong>。</p><p>而<code>哨兵模式</code>，在<code>复制</code>的基础上，实现了<code>自动化的故障恢复</code>。<code>缺陷</code>有：<strong>写操作无法负载均衡</strong>；<strong>存储能力受到单机的限制</strong>。</p><p><code>集群模式</code>，Redis<strong>解决</strong>了<code>写操作无法负载均衡</code>，以及<code>存储能力受到单机限制</code>的问题，实现了较为<code>完善的高可用方案</code>。</p><p>下图为Redis 集群（Cluster）示意图：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster.jpg"></p><div class="caption"><b class="center-caption">Redis 集群模式示意图</b></div><p></p><h1 id="2-机制"><a href="#2-机制" class="headerlink" title="2 机制"></a>2 机制</h1><h2 id="2-1-设计目标"><a href="#2-1-设计目标" class="headerlink" title="2.1 设计目标"></a>2.1 设计目标</h2><p>Redis 集群是 Redis 的分布式实现，<code>Redis3.0以后版本</code>正式提供支持。在设计中按重要性顺序具有以下目标：</p><ul><li>高性能和线性可扩展性，多达 <code>1000</code> 个节点。没有代理，使用<code>异步复制</code>，并且不对值执行合并操作。</li><li>可接受的写入安全：系统尝试(采用<code>best-effort</code>方式)保留所有连接到master节点的client发起的写操作。通常会有一个小的时间窗，时间窗内的已确认写操作可能丢失(即，在发生failover之前的小段时间窗内的写操作可能在failover中丢失)。而在(网络)分区故障下，对少数派master的写入，发生写丢失的时间窗会很大。</li><li>可用性：<code>Redis Cluster</code>在以下场景下集群总是可用：<ul><li>大部分master节点可用，并且对少部分不可用的master，每一个master至少有一个当前可用的slave。</li><li>更进一步，通过使用<code>replicas migration</code>技术，当前没有slave的master会从当前拥有多个slave的master接受到一个新slave来确保可用性。</li></ul></li></ul><h1 id="3-模块"><a href="#3-模块" class="headerlink" title="3 模块"></a>3 模块</h1><h2 id="3-1-哈希槽-Hash-Slot"><a href="#3-1-哈希槽-Hash-Slot" class="headerlink" title="3.1 哈希槽(Hash Slot)"></a>3.1 哈希槽(Hash Slot)</h2><p>Redis-Cluster没有使用一致性hash，而是引入了<code>哈希槽</code>的概念。</p><p>Redis-cluster中有<code>16384</code>(即$2^{14}$）个哈希槽，每个<code>key</code>通过<code>CRC16</code>校验后对<code>16383</code>取模来决定放置哪个槽。</p><p>Cluster中的每个节点负责一部分<code>哈希槽</code>（hash slot）。比如集群中存在三个节点，则可能存在的一种分配如下：</p><ul><li>节点A包含<code>0~5500</code>号哈希槽；</li><li>节点B包含<code>5501~11000</code>号哈希槽；</li><li>节点C包含<code>11001~16384</code>号哈希槽。</li></ul><h2 id="3-2-Hash-tags"><a href="#3-2-Hash-tags" class="headerlink" title="3.2 Hash tags"></a>3.2 Hash tags</h2><p>提供了一种途径，用来将<code>多个(相关的)key</code>分配到<code>相同的hash slot</code>中。这时Redis Cluster中实现<code>multi-key</code>操作的基础。</p><p><code>Hash tag规则</code>如下：</p><ul><li>如果key包含<code>&#123;...&#125;</code>模式，则仅对<code>&#123;</code>和<code>&#125;</code>之间的<code>子字符串</code>（即：<code>...</code>）进行哈希处理，以获取哈希槽。</li><li>但是，由于可能存在多次出现<code>&#123;</code>或<code>&#125;</code>，则算法由以下规则指定：<ul><li>key包含一个<code>&#123;</code>字符；</li><li>并且如果在这个<code>&#123;</code>的右面有一个<code>&#125;</code>字符；</li><li>并且如果在<code>&#123;</code>和<code>&#125;</code>之间存在<code>至少一个字符</code><br>然后，不对key进行哈希处理，而只对<code>第一次</code>出现<code>&#123;</code>和下一个第一次出现<code>&#125;</code>之间的内容进行哈希处理。</li></ul></li></ul><p>举例：</p><ol><li><code>&#123;user1000&#125;.following</code>和<code>&#123;user1000&#125;.followers</code>这两个key会被hash到<code>相同的hash slot</code>中，因为只有<code>user1000</code>会被用来计算hash slot值。</li><li><code>foo&#123;&#125;&#123;bar&#125;</code>这个key不会启用<code>hash tag</code>，因为第一个<code>&#123;</code>和<code>&#125;</code>之间<strong>没有字符</strong>。</li><li><code>foo&#123;&#123;bar&#125;&#125;zap</code>这个key中的<code>&#123;bar</code>部分会被用来计算<code>hash slot</code>；</li><li><code>foo&#123;bar&#125;&#123;zap&#125;</code>这个key中的<code>bar</code>会被用来计算计算<code>hash slot</code>，而<code>zap</code>不会。<blockquote><p>从算法得出的结论是，如果key以<code>&#123;&#125;</code>打头，则保证将其作为<code>一个整体进行哈希处理</code>。这在使用<code>二进制数据</code>作为<code>键名</code>时很有用。</p></blockquote></li></ol><h2 id="3-3-集群节点属性"><a href="#3-3-集群节点属性" class="headerlink" title="3.3 集群节点属性"></a>3.3 集群节点属性</h2><h3 id="3-3-1-节点名称（node-name）"><a href="#3-3-1-节点名称（node-name）" class="headerlink" title="3.3.1 节点名称（node name）"></a>3.3.1 节点名称（node name）</h3><p>每个节点在集群中都有一个<code>唯一的名称</code>。<code>节点名称</code>是 <code>160 位十六进制的随机数</code>表示形式，在节点<code>首次启动</code>时获得（通常使用 <code>/dev/urandom</code>）。</p><p>节点将把其 <code>ID</code> 保存在节点配置文件中，并将<code>永远使用相同的 ID</code>，或者至少只要<code>系统管理员</code>未删除节点配置文件，或者通过 <code>CLUSTER RESET</code> 命令请求硬重置。</p><p><code>节点ID</code>被用来标识整个cluster中每个节点。一个节点可以修改自己的<code>IP地址</code>而不需要修改自己的<code>ID</code>。Cluster可以检测到<code>IP/port</code>的改动并通过运行在cluster bus上的<code>gossip协议</code>重新配置该节点。</p><p><strong>节点ID不是唯一与节点绑定的信息</strong>，但是他是<code>唯一的一个总是保持全局一致的字段</code>。</p><h3 id="3-3-2-其他属性"><a href="#3-3-2-其他属性" class="headerlink" title="3.3.2 其他属性"></a>3.3.2 其他属性</h3><p>除了<code>节点ID</code>，集群节点还包含以下信息：<br><code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个<code>slave或replica</code>节点），<code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code>，<code>当前的节点configuration epoch</code>，<code>链接状态</code>，以及最后是该节点服务的<code>hash slots</code>。</p><p>下面是一个发送到一个拥有<code>3个节点</code>的小集群的<code>master节点</code>的<code>CLUSTER NODES</code>输出的例子。<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli cluster nodes

d1861060fe6a534d42d8a19aeb36600e18785e04  <span class="token number">127.0</span>.0.1:6379 myself - <span class="token number">0</span>                   <span class="token number">1318428930</span> <span class="token number">1</span> connected <span class="token number">0</span>-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae   <span class="token number">127.0</span>.0.1:6380 master - <span class="token number">1318428930</span> <span class="token number">1318428931</span> <span class="token number">2</span> connected <span class="token number">1365</span>-2729
d289c575dcbc4bdd2931585fd4339089e461a27d  <span class="token number">127.0</span>.0.1:6381 master - <span class="token number">1318428931</span> <span class="token number">1318428931</span> <span class="token number">3</span> connected <span class="token number">2730</span>-4095<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在上面的列表中，不同的字段按顺序排列：<code>节点ID</code>，<code>地址：端口</code>，<code>标志</code>，<code>上次发送ping的时间戳</code>，<code>收到的最后一个pong的时间戳</code>，<code>配置纪元</code>，<code>链路状态</code>，<code>插槽</code>。</p><h2 id="3-4-集群总线"><a href="#3-4-集群总线" class="headerlink" title="3.4 集群总线"></a>3.4 集群总线</h2><p>每个Redis 集群节点都有一个<code>额外的 TCP 端口</code>，用于接收来自其他 Redis 集群节点的传入连接。</p><p>比如，</p><ul><li>如果 Redis 节点正在侦听端口 <code>6379</code> 上的客户端连接，并且您<strong>没有</strong>在 <code>redis.conf</code> 中添加集群端口参数，则将打开集群总线端口 <code>16379</code>。</li><li>如果 Redis 节点正在侦听端口 <code>6379</code> 上的客户端连接，并且您在 <code>redis.conf</code> 中设置了集群端口 <code>20000</code>，则会打开集群总线端口 <code>20000</code>。</li></ul><p><code>节点到节点通信</code>仅使用<code>集群总线</code>和<code>集群总线协议</code>进行：由不同类型和大小的帧组成的二进制协议。</p><blockquote><p>集群总线二进制协议未公开记录，因为它不适用于外部软件设备使用此协议与 Redis 集群节点通信。但是，您可以通过阅读 Redis 集群源代码中的 <code>cluster.h</code> 和 <code>cluster.c</code> 文件来获取有关集群总线协议的更多详细信息。</p></blockquote><h2 id="3-5-集群拓扑"><a href="#3-5-集群拓扑" class="headerlink" title="3.5 集群拓扑"></a>3.5 集群拓扑</h2><ul><li>Redis 集群是一个完整的网格，其中每个节点都使用 TCP 连接与其他节点连接。</li><li>在由 <code>N</code> 个节点组成的集群中，每个节点都有 <code>N-1</code> 个传出 TCP 连接和 <code>N-1</code> 个传入连接。</li><li>这些 TCP 连接<code>始终保持活动状态</code>，而不是按需创建。当节点期望 pong 回复以响应集群总线中的 ping 时，在等待足够长的时间将节点标记为无法访问之前，它将尝试通过从头开始重新连接来刷新与节点的连接。</li><li>虽然 Redis 集群节点形成全网状，但节点使用 <code>gossip 协议</code>和<code>配置更新</code>机制，以避免在正常情况下节点之间交换过多消息，因此交换的消息数量不是指数级的。</li></ul><h2 id="3-6-节点握手"><a href="#3-6-节点握手" class="headerlink" title="3.6 节点握手"></a>3.6 节点握手</h2><p>节点总是接受<code>集群总线端口</code>的链接，并且总是会回复<code>ping请求</code>，即使<code>ping</code>来自一个不可信节点。然而，如果发送节点被认为<strong>不是</strong>当前集群的一部分，所有其他包将被抛弃。</p><p>节点认定其他节点是当前集群的一部分有<code>两种方式</code>：</p><ul><li>如果一个节点出现在了一条<code>MEET消息</code>中。一条<code>MEET消息</code>非常像一个<code>PING消息</code>，但是它会<code>强制</code>接收者接受一个节点作为集群的一部分。节点只有在接收到系统管理员的如下命令后，才会向其他节点发送<code>MEET消息</code>：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CLUSTER MEET <span class="token function">ip</span> port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>如果一个被信任的节点<code>gossip</code>了某个节点，那么接收到<code>gossip消息</code>的节点也会把那个节点标记为集群的一部分。也就是说，如果在集群中，<code>A</code>知道<code>B</code>，而<code>B</code>知道<code>C</code>，最终<code>B</code>会发送<code>gossip消息</code>到<code>A</code>，告诉<code>A</code>节点<code>C</code>是集群的一部分。这时，<code>A</code>会把<code>C</code><strong>注册</strong>为网络的一部分，并尝试与<code>C</code>建立连接。</li></ul><p>这意味着，一旦我们把某个节点加入了<code>连接图</code>(connected graph)，它们最终会自动形成一张<code>全连接图</code>(fully connected graph)。</p><p>这也意味着只要<code>系统管理员</code><strong>强制</strong>加入了一条信任关系（在某个节点上通过meet命令加入了一个新节点），集群可以自动发现其他节点。</p><blockquote><p>Gossip协议<sup><a href="#fn_3" id="reffn_3">3</a></sup><br>节点间通信，按照通信协议可以分为几种类型：<code>单对单</code>、<code>广播</code>、<code>Gossip协议</code>等。重点是广播和Gossip的对比。</p><ul><li><code>广播</code>是指向集群内所有节点发送消息；<ul><li><code>优点</code>：集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)；</li><li><code>缺点</code>：每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li></ul></li><li><code>Gossip协议</code>的特点是：在节点数量有限的网络中，每个节点都<code>“随机”</code>的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。<ul><li><code>优点</code>：负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；</li><li><code>缺点</code>：主要是集群的收敛速度慢。</li></ul></li></ul></blockquote><h1 id="4-功能"><a href="#4-功能" class="headerlink" title="4 功能"></a>4 功能</h1><h2 id="4-1-数据分片"><a href="#4-1-数据分片" class="headerlink" title="4.1 数据分片"></a>4.1 数据分片</h2><p>作用：</p><ul><li>Redis Cluster将数据按<code>key</code>哈希到<code>16384</code>个slot上；</li><li>Cluster中的不同节点负责<code>一部分slot</code>。</li></ul><p>两个动作：</p><ul><li>分片：将slots划分给不同节点的过程；</li><li>再分配：将一些slots从当前节点(source)迁移到其他节点(target)。</li></ul><p>常见的分片算法有：哈希取余分区、一致性哈希分区<sup><a href="#fn_2" id="reffn_2">2</a></sup>、带虚拟节点的一致性哈希分区</p><h3 id="4-1-1-哈希取余分区"><a href="#4-1-1-哈希取余分区" class="headerlink" title="4.1.1 哈希取余分区"></a>4.1.1 哈希取余分区</h3><ul><li>原理：计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</li><li>优点：简单、快速、高效、适用于大规模快速查询。</li><li>缺点：<ul><li><code>数据分布不均匀</code>：如果使用简单的哈希取余算法，可能会出现<code>数据倾斜</code>的情况，导致某些节点负载过高，而某些节点负载过轻；</li><li><code>数据迁移困难</code>：使用哈希取余算法进行数据分布后，如果需要添加或删除节点，就需要重新计算每个数据对应的节点，然后将其迁移到新节点上，这个过程非常繁琐，而且需要<code>暂停</code>对集群的<code>写操作</code>；</li><li><code>扩展性受限</code>：使用哈希取余算法进行数据分布时，如果需要增加节点，那么需要将所有的数据重新计算分配，这样就会<code>限制集群的扩展性</code>；</li><li><code>大量缓存重建问题</code>：主节点如果宕机，那么Hash运算时根据现有存活节点进行取模，得到的数值与原有存储数据时的数值不匹配，请求走不到原有路由节点上，从而导致大量的key瞬间全部失效。</li></ul></li></ul><h3 id="4-1-2-一致性哈希分区"><a href="#4-1-2-一致性哈希分区" class="headerlink" title="4.1.2 一致性哈希分区"></a>4.1.2 一致性哈希分区</h3><ul><li>原理：将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0~$2^{32}$-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环<code>顺时针</code>行走，找到的<code>第一台</code>服务器就是其应该映射到的服务器。数据的存储与读取都在此节点进行。</li><li>优点：保证任何一个主节点宕机，只会影响在之前那个主节点上的数据，此前的主节点宕机，查询时这部分数据会丢失，写入时沿着<code>顺时针</code>去到下一个主节点；</li><li>缺点：<ul><li><code>数据丢失过大</code>：在节点比较少的情况下， 丢失的数据量还是非常庞大的；</li><li><code>缓存热点问题</code>：如果某些数据被频繁地访问，会导致热点数据集中在某个节点上，造成负载不均；</li><li><code>数据倾斜问题</code>：节点数量较少时，由于数据分布不均，可能会导致某个节点负载过重，影响系统的性能。这是因为Hash函数的输出值在Hash环上<code>并不是均匀分布的</code>，而是有规律的。一致性哈希算法可以通过引入<code>虚拟节点</code>来解决这个问题，将每个物理节点映射到多个虚拟节点上，使得数据更加均匀地分布在环上；</li><li><code>一致性问题</code>：由于节点的添加或删除会影响哈希值的计算，可能会导致数据分布不均，这个问题可以通过一些技术手段来解决，例如虚拟节点、数据复制等</li></ul></li></ul><h3 id="4-1-3-带虚拟节点的一致性哈希分区"><a href="#4-1-3-带虚拟节点的一致性哈希分区" class="headerlink" title="4.1.3 带虚拟节点的一致性哈希分区"></a>4.1.3 带虚拟节点的一致性哈希分区</h3><ul><li>原理：该方案在一致性哈希分区的基础上，引入了<code>虚拟节点</code>的概念。Redis集群使用的便是该方案，其中的虚拟节点称为<code>槽</code>（slot）。<ul><li><code>槽</code>是介于<code>数据</code>和<code>实际节点</code>之间的虚拟概念；</li><li>每个实际节点包含<code>一定数量</code>的槽，每个槽包含哈希值在<code>一定范围内</code>的数据。</li><li>引入槽以后，数据的映射关系由<code>数据hash</code>-&gt;<code>实际节点</code>，变成了<code>数据hash</code>-&gt;<code>槽</code>-&gt;<code>实际节点</code>。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster-Consistent-Hash-with-Slot.png"><div class="caption"><b class="center-caption">Redis-Cluster的一致性哈希原理示意图</b></div></li></ul></li><li>过程<ul><li>在<code>HashSlot算法</code>中，取值范围是<code>0~16383</code>。Redis将整个key空间分成了<code>16384</code>个槽，也就是16384个slot，每个主节点负责<code>一部分槽</code>；</li><li>客户端根据<code>Key</code>计算<code>CRC16</code>值，将值对16384<code>取模</code>，找到对应的<code>槽</code>，然后根据槽对应的<code>主节点</code>进行数据访问；</li><li>Redis中的每个<code>主节点</code>都对应一部分槽位。增加一个主节点时，只需要将其他主节点的槽位分配一部分到新槽位。删除一个主节点时，就将此主节点的槽位移动到其他的主节点上去。<strong>移动Hash槽的成本是非常低的</strong>；</li><li><code>HashSlot算法</code>还可以将不同的数据类型映射到不同的槽中，以达到更好的负载均衡效果。同时，Redis还支持将相邻的多个槽划分到同一个节点，以便在某些场景下提高数据读取的效率；</li><li>如果想确保一些Key总是被分配到同一个节点，那么您可以使用<code>哈希标签</code>（Hash Tag）功能来强制让这些键映射到同一个槽位。</li><li><blockquote><p>哈希标签是在 RedisKey 上使用大括号 <code>&quot;&#123;&#125;&quot;</code> 的一种特殊语法，详见3.2节。例如：<code>set mykey1:&#123;100&#125;</code>和<code>set mykey2:&#123;100&#125;</code>，它们的<code>hash tag</code>都是<code>&#123;100&#125;</code>，那么它们就会被存储在<code>同一个hash slot</code>中.</p></blockquote></li></ul></li></ul><blockquote><p>16384槽位由来<br><code>CRC16算法</code>产生的Hash值有<code>16bit</code>，该算法可以产生<code>65536</code>个值。值是分布在<code>0~65535</code>之间，那么其实在做取模运算时，我们是可以取模<code>65536</code>的，但是Redsi作者采取了<code>16384</code>;<br>作者的回答<sup><a href="#fn_1" id="reffn_1">1</a></sup>是：Redis集群节点数量如果<code>超过1000个</code>那么会造成<code>网络拥堵</code>，所以建议节点数量<code>不超过1000个</code>，那么1000个节点使用<code>16384</code>个槽位完全够用了。如果使用<code>65536</code>个槽位会导致主节点之间交互心跳包时，<code>浪费带宽</code>。槽位数量过少不够用，过多浪费带宽，所以作者通过实测计算得出一个16384的值，不多不少刚刚好。</p></blockquote><ul><li>读写分离<ul><li>默认情况下RedisCluster<code>读写</code>都是通过<code>主节点</code>进行处理，<code>不支持从节点读写</code>。RedisCluster的核心理念是<strong>从节点是作为热备以及主节点宕机时从节点进行故障转移</strong>，从而实现高可用;</li><li>Redis之所以需要读写分离，是为了<code>横向扩展从节点</code>去达到更高地<code>读并发</code>。而在RedisCluster中，主节点本身就可以任意横向扩展，如果想要更高地读写并发，那么对<strong>主节点进行横向扩展</strong>即可;</li><li>想要在RedisCluster中实现读写分离代价是比较高的，比如可以修改JedisClient源码，或是使用第三方RedisProxy工具.<h2 id="4-2-请求重定向"><a href="#4-2-请求重定向" class="headerlink" title="4.2 请求重定向"></a>4.2 请求重定向</h2><h3 id="4-2-1-MOVE"><a href="#4-2-1-MOVE" class="headerlink" title="4.2.1 MOVE"></a>4.2.1 MOVE</h3>步骤：</li></ul></li><li>‘我’并不负责‘你’要的key，告诉’你‘正确的吧。</li><li>返回<code>CLUSTER_REDIR_MOVED</code>错误，和<code>正确的节点</code>。</li><li>客户端向该【正确的节点】重新发起请求，注意这次依然有发生<code>重定向</code>的可能。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Move-Redirect.png"><div class="caption"><b class="center-caption">Move重定向</b></div><h3 id="4-2-2-ASK"><a href="#4-2-2-ASK" class="headerlink" title="4.2.2 ASK"></a>4.2.2 ASK</h3>步骤：</li><li>‘我’负责请求的key，但不巧的这个key当前在<code>migraging</code>状态，且‘我’这里已经取不到了。告诉‘你’<code>importing</code>他的‘家伙’吧，去碰碰运气。</li><li>返回<code>CLUSTER_REDIR_ASK</code>，和<code>importing</code>该key的节点。</li><li>客户端向新节点发送<code>ASKING</code>，之后再次发起请求</li><li>新节点对发送过<code>ASKING</code>，且key已经<code>migrate</code>过来的请求进行响应。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Asking-Redirect.png"><div class="caption"><b class="center-caption">Ask重定向</b></div></li></ul><h3 id="4-2-3-区别"><a href="#4-2-3-区别" class="headerlink" title="4.2.3 区别"></a>4.2.3 区别</h3><p>区分这两种重定向的场景是非常有必要的：</p><ul><li><code>MOVE</code>，申明的是slot<code>所有权</code>的转移，收到的客户端需要更新其<code>key-node</code>映射关系；</li><li><code>ASK</code>，申明的是一种<code>临时的状态</code>，<strong>所有权还并没有转移</strong>，客户端并不更新其映射关系。前面加的<code>ASKING</code>命令也是申明其理解当前的这种临时状态。</li></ul><h2 id="4-3-状态检测及维护"><a href="#4-3-状态检测及维护" class="headerlink" title="4.3 状态检测及维护"></a>4.3 状态检测及维护</h2><h3 id="4-3-1-状态"><a href="#4-3-1-状态" class="headerlink" title="4.3.1 状态"></a>4.3.1 状态</h3><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态</li><li>集群中各节点所负责的slots信息，及其migrate状态</li><li>集群中各节点的master-slave状态</li><li>集群中各节点的存活状态及不可达投票</li></ul><p>当集群状态变化时，如<code>新节点加入</code>、<code>slot迁移</code>、<code>节点宕机</code>、<code>slave提升为新Master</code>，我们希望这些变化尽快的被发现，<code>传播</code>到整个集群的所有节点并达成一致。</p><p>节点之间相互的<code>心跳</code>（PING，PONG，MEET）及其携带的数据是集群状态传播最主要的途径。</p><h3 id="4-3-2-Gossip协议"><a href="#4-3-2-Gossip协议" class="headerlink" title="4.3.2 Gossip协议"></a>4.3.2 Gossip协议</h3><ul><li><p>Gossip优点</p><ul><li><code>分布式高效</code>：Gossip协议是一种<code>去中心化</code>的协议，节点之间相互交流信息，每个节点都可以通过传播信息来实现全局一致性，不需要中央控制节点，使得节点加入或退出集群更加高效；</li><li><code>可伸缩性</code>：Gossip协议可以很好地适应不同规模的系统，当节点数目增加时，节点间通信的成本是对数级别的；</li><li><code>容错性</code>：Gossip协议具有一定的容错能力，由于每个节点可以通过交互信息来更新状态，因此即使一部分节点失效，其他节点仍然可以更新状态，保持整个集群的<code>一致性</code>；</li><li><code>自适应性</code>：Gossip协议在传输信息时会根据实时情况进行调整，根据反馈信息和可靠性要求，自动选择合适的节点进行信息交流，从而提高了信息传输的效率和可靠性；</li><li><code>低延迟</code>：Gossip协议采用分散的信息传播方式，信息可以在整个网络中快速地传播，从而使得系统的响应速度更快。</li></ul></li><li><p>Gossip缺点</p><ul><li><code>延迟问题</code>：由于Gossip协议的传播速度相对较慢，因此可能存在节点状态更新的延迟问题。特别是在网络拓扑结构较为复杂或节点数量较大时，这种延迟问题会更加突出；</li><li><code>带宽开销</code>：由于Gossip协议的信息需要在节点之间不断传播，因此可能会产生较大的网络带宽开销。特别是在节点数量较大时，这种开销会更加严重；</li><li><code>数据一致性问题</code>：由于Gossip协议是基于随机的节点通信机制实现的，因此可能会出现数据不一致的情况。特别是在节点状态频繁变化时，这种问题会更加明显；</li><li><code>安全性问题</code>：Gossip协议需要在节点之间传递敏感信息，因此存在安全性问题。特别是在没有适当的加密和认证机制时，这种问题会更加严重。</li></ul></li></ul><p>3.6节大致提了一嘴Gossip协议，这里讲讲在Redis Cluster中的应用。</p><h4 id="4-3-2-1-Gossip协议的使用"><a href="#4-3-2-1-Gossip协议的使用" class="headerlink" title="4.3.2.1 Gossip协议的使用"></a>4.3.2.1 Gossip协议的使用</h4><p>Redis 集群是<code>去中心化</code>的，彼此之间状态同步靠 <code>gossip 协议</code>通信，集群的消息有以下几种类型：</p><ul><li><code>Meet</code>：通过<code>cluster meet ip port</code>命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><code>Ping</code>：节点<code>每秒</code>会向集群中其他节点发送 <code>ping 消息</code>，消息中带有自己已知的两个节点的<code>地址</code>、<code>槽</code>、<code>状态信息</code>、<code>最后一次通信时间</code>等。</li><li><code>Pong</code>：节点收到 <code>ping 消息</code>后会回复 <code>pong 消息</code>，消息中同样带有自己已知的两个节点信息。</li><li><code>Fail</code>：节点 <code>ping</code> 不通某节点后，会向集群所有节点<code>广播</code>该节点<code>挂掉</code>的消息。其他节点收到消息后标记<code>已下线</code>。</li></ul><h4 id="4-3-2-2-基于Gossip协议的故障检测"><a href="#4-3-2-2-基于Gossip协议的故障检测" class="headerlink" title="4.3.2.2 基于Gossip协议的故障检测"></a>4.3.2.2 基于Gossip协议的故障检测</h4><p>集群中的每个节点都会<code>定期</code>地向集群中的其他节点发送<code>PING消息</code>，以此交换各个节点状态信息，检测各个节点状态：<code>在线状态</code>、<code>疑似下线状态PFAIL</code>、<code>已下线状态FAIL</code>。</p><ul><li><code>自己保存信息</code>：当<code>主节点A</code>通过消息得知<code>主节点B</code>认为<code>主节点D</code>进入了<code>疑似下线</code>(PFAIL)状态时，<code>主节点A</code>会在自己的<code>clusterState.nodes</code>字典中找到<code>主节点D</code>所对应的<code>clusterNode</code>结构，并将<code>主节点B</code>的<strong>下线报告</strong>添加到clusterNode结构的<code>fail_reports链表</code>中，并后续关于<code>主节点D</code><strong>疑似下线</strong>的状态通过<code>Gossip协议</code>通知其他节点。</li><li><code>一起裁定</code>：如果集群里面，<code>半数以上</code>的<strong>主节点</strong>都将<code>主节点D</code>报告为<code>疑似下线</code>，那么<code>主节点D</code>将被标记为<code>已下线</code>(FAIL)状态，将<code>主节点D</code>标记为<code>已下线</code>的节点会向集群<strong>广播</strong><code>主节点D</code>的<code>FAIL消息</code>，所有收到FAIL消息的节点都会立即更新nodes里面<code>主节点D</code>状态标记为<code>已下线</code>。</li><li><code>最终裁定</code>：将 node 标记为 FAIL 需要满足以下<code>两个条件</code>：<ul><li>有<code>半数以上</code>的<strong>主节点</strong>将 node 标记为 <code>PFAIL</code> 状态。</li><li><code>当前节点</code>也将 node 标记为 <code>PFAIL</code> 状态。</li></ul></li></ul><blockquote><p>相关数据结构：</p><ul><li>clusterState：从当前节点的视角来看的集群状态，每个节点维护一份<ul><li>myself：指针指向自己的clusterNode</li><li>currentEpoch：当前节点见过的最大epoch，可能在心跳包的处理中更新</li><li>nodes：当前节点感知到的所有节点，为clusterNode指针数组</li><li>slots：slot与clusterNode指针映射关系</li><li>migrating_slots_to, importing_slots_from：记录slots的迁移信息</li><li>failover_auth_time, failover_auth_count, failover_auth_sent, failover_auth_rank, failover_auth_epoch：Failover相关</li></ul></li><li>clusterNode：代表集群中的一个节点<ul><li>slots：位图，由当前clusterNode负责的slot为1</li><li>salve, slaveof：主从关系信息</li><li>ping_sent, pong_received：心跳包收发时间</li><li>clusterLink *link：Node间的联接</li><li>list *fail_reports：收到的节点不可达投票</li></ul></li><li>clusterLink，负责处理网络上的一条链接来的内容。</li></ul></blockquote><h3 id="4-3-3-心跳"><a href="#4-3-3-心跳" class="headerlink" title="4.3.3 心跳"></a>4.3.3 心跳</h3><h4 id="4-3-3-1-心跳时机"><a href="#4-3-3-1-心跳时机" class="headerlink" title="4.3.3.1 心跳时机"></a>4.3.3.1 心跳时机</h4><p>Redis节点会记录其向每一个节点<strong>上一次</strong>发出<code>ping</code>和收到<code>pong</code>的<code>时间</code>（详见3.3.2节），心跳发送时机与这两个值有关。通过下面的方式既能保证及时更新集群状态，又不至于使心跳数过多：</p><ul><li>每次Cron向所有<code>未建立链接</code>的节点发送<code>ping</code>或<code>meet</code>；</li><li><code>每1秒</code>从所有<code>已知节点</code>中<strong>随机选取5个</strong>，向其中<strong>上次收到pong最久远</strong>的一个发送<code>ping</code>；</li><li>每次Cron向收到<code>pong</code>超过<code>timeout/2</code>的节点发送<code>ping</code>；</li><li>收到<code>ping</code>或<code>meet</code>，立即回复<code>pong</code>。</li></ul><h4 id="4-3-3-2-心跳数据"><a href="#4-3-3-2-心跳数据" class="headerlink" title="4.3.3.2 心跳数据"></a>4.3.3.2 心跳数据</h4><ul><li><code>Header</code>：发送者自己的信息<ul><li>所负责slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul></li><li><code>Gossip</code>：发送者所了解的部分其他节点的信息<ul><li>ping_sent, pong_received</li><li>ip, port信息</li><li>状态信息，比如发送者认为该节点已经不可达，会在状态信息中标记其为<code>PFAIL</code>或<code>FAIL</code></li></ul></li></ul><h4 id="4-3-3-3-心跳处理"><a href="#4-3-3-3-心跳处理" class="headerlink" title="4.3.3.3 心跳处理"></a>4.3.3.3 心跳处理</h4><ul><li><code>新节点加入</code><ul><li>发送<code>meet包</code>加入集群</li><li>从<code>pong包</code>中的gossip得到未知的其他节点</li><li>循环上述过程，直到最终加入集群<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster-NewNode.jpg"><div class="caption"><b class="center-caption">新节点加入</b></div></li></ul></li><li><code>Slots信息</code><ul><li>判断发送者声明的<code>slots</code>信息，跟本地记录的是否有不同<ul><li>如果不同，且发送者<code>epoch</code>较大，更新本地记录</li><li>如果不同，且发送者<code>epoch</code>小，发送<code>Update信息</code>通知发送者</li></ul></li></ul></li><li>Master slave信息：发现发送者的<code>master</code>、<code>slave</code>信息变化，更新本地状态</li><li>节点Fail探测<ul><li>超过<code>超时时间</code>仍然没有收到<code>pong包</code>的节点会被当前节点标记为<code>PFAIL</code></li><li><code>PFAIL</code>标记会随着gossip传播</li><li>每次收到心跳包会检测其中对其他节点的<code>PFAIL</code>标记，当做对该节点<code>FAIL</code>的投票维护在本机</li><li>对某个节点的<code>PFAIL</code>标记达到<code>大多数</code>时，将其变为<code>FAIL标记</code>并<code>广播FAIL消息</code>。</li></ul></li></ul><h3 id="4-3-4-广播"><a href="#4-3-4-广播" class="headerlink" title="4.3.4 广播"></a>4.3.4 广播</h3><p>当需要发布一些<code>非常重要</code>且<code>需要立即送达</code>的信息时，上述心跳加Gossip的方式就显得捉襟见肘了，这时就需要向所有集群内机器的<code>广播</code>信息，使用广播发消息的场景：</p><ul><li>节点的Fail信息：当发现某一节点不可达时，探测节点会将其标记为<code>PFAIL</code>状态，并通过<code>心跳</code>传播出去。当某一节点发现这个节点的<code>PFAIL</code>超过半数时修改其为<code>FAIL</code>并发起广播；</li><li>Failover Request信息：slave尝试发起<code>FailOver</code>时广播其要求投票的信息；</li><li>新Master信息：Failover成功的节点向整个集群广播自己的信息。</li></ul><h2 id="4-4-故障恢复（Failover）"><a href="#4-4-故障恢复（Failover）" class="headerlink" title="4.4 故障恢复（Failover）"></a>4.4 故障恢复（Failover）</h2><p>当slave发现自己的master变为<code>FAIL</code>状态时，便尝试进行<code>Failover</code>，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过<code>类Raft协议</code>的过程在整个集群内达到一致， 其过程如下：</p><ul><li>slave发现自己的master变为<code>FAIL</code>；</li><li>将自己记录的集群<code>currentEpoch加1</code>，并广播<code>Failover Request信息</code>；</li><li>其他节点收到该信息，<strong>只有master响应</strong>，判断请求者的合法性，并发送<code>FAILOVER_AUTH_ACK</code>，对每一个epoch只发送一次ack；</li><li>尝试failover的slave收集<code>FAILOVER_AUTH_ACK</code>；</li><li><code>超过半数后</code>变成新Master；</li><li>广播<code>Pong</code>通知其他集群节点。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster-Failover.jpg"><div class="caption"><b class="center-caption">Failover</b></div></li></ul><h2 id="4-5-扩容-amp-缩容"><a href="#4-5-扩容-amp-缩容" class="headerlink" title="4.5 扩容&amp;缩容"></a>4.5 扩容&amp;缩容</h2><h3 id="4-5-1-扩容"><a href="#4-5-1-扩容" class="headerlink" title="4.5.1 扩容"></a>4.5.1 扩容</h3><ul><li>新节点向集群中的一个已知节点发送 <code>meet 命令</code>请求加入集群；</li><li>已知节点向集群中<code>其他节点</code>发送 <code>meet 命令</code>，将新节点加入集群；（新添加的节点默认在集群中都是<code>主节点</code>。）</li><li>新节点加入集群后，会通过 <code>ping/pong</code> 报文与其他节点建立<code>心跳连接</code>，<code>同步集群信息</code>，包括集群节点的数量、槽位信息等；</li></ul><p>当新节点成为集群的一员时，集群中的<code>数据迁移</code>将开始，数据迁移过程中对客户端是透明的。具体的数据迁移过程如下</p><ul><li>集群会从<code>所有原节点</code>中选取<code>一部分槽位</code>的数据迁移到新节点上，具体的迁移槽位和数量取决于集群中的数据分布情况；</li><li>在数据迁移期间，如果有客户端访问迁移的槽位，集群会返回一个 <code>ASK 错误</code>，告知客户端要访问的槽位已经迁移到了新节点上，同时告知客户端新节点的地址，客户端会根据返回的地址重新发起请求；</li><li>当所有数据迁移完成后，集群会向客户端返回<code>MOVED信息</code>，告知客户端对应的槽位已经迁移到了新节点上；</li><li>客户端收到<code>MOVED信息</code>后，会更新本地的<code>【槽位/节点映射表】</code>，以便后续请求可以直接定位到新节点。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster-Migration.png"><div class="caption"><b class="center-caption">Redis数据迁移</b></div></li></ul><h3 id="4-5-2-缩容"><a href="#4-5-2-缩容" class="headerlink" title="4.5.2 缩容"></a>4.5.2 缩容</h3><ul><li>确定下线的节点是否有负责槽（是否是主节点），如果是，需要把槽迁移到其他节点，保证节点下线后整个槽节点映射的完整性。</li><li>当下线节点不在负责槽或着本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有节点忘记该节点后就可以正常关闭。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Cluster-Degrade.png"><div class="caption"><b class="center-caption">Redis集群缩容过程</b></div><blockquote><p>一般是先下线从节点，再下线主节点。以免不必要的全量同步。</p></blockquote></li></ul><h1 id="5-其它常见方案"><a href="#5-其它常见方案" class="headerlink" title="5 其它常见方案"></a>5 其它常见方案</h1><h2 id="5-1-Redis-Sentinel-集群-Keepalived-Haproxy"><a href="#5-1-Redis-Sentinel-集群-Keepalived-Haproxy" class="headerlink" title="5.1 Redis Sentinel 集群 + Keepalived/Haproxy"></a>5.1 Redis Sentinel 集群 + Keepalived/Haproxy</h2><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Sentinel-Keepalived2.png"><div class="caption"><b class="center-caption">Redis Sentinel 集群 + Keepalived</b></div><ul><li>优点：<ul><li>秒级切换</li><li>对应用透明</li></ul></li><li>缺点：<ul><li>维护成本高</li><li>存在脑裂</li><li>Sentinel 模式存在短时间的服务不可用</li></ul></li></ul><h2 id="5-2-Twemproxy"><a href="#5-2-Twemproxy" class="headerlink" title="5.2 Twemproxy"></a>5.2 Twemproxy</h2><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Twemproxy.png"><div class="caption"><b class="center-caption">Twemproxy</b></div><ul><li>优点：开发简单，对应用几乎透明历史悠久，方案成熟</li><li>缺点：<ul><li>代理影响性能</li><li><code>LVS</code>和 <code>Twemproxy</code> 会有节点性能瓶颈</li><li>Redis 扩容非常麻烦</li><li>Twitter 内部已放弃使用该方案，新使用的架构未开源</li></ul></li></ul><h2 id="5-3-Codis"><a href="#5-3-Codis" class="headerlink" title="5.3 Codis"></a>5.3 Codis</h2><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Codis.png"><div class="caption"><b class="center-caption">Codis</b></div><p><code>Codis</code>是由豌豆荚开源的产品，涉及组件众多，其中 <code>ZooKeeper</code> 存放路由表和代理节点元数据、分发 Codis-Config 的命令；<br><code>Codis-Config</code>是集成管理工具，有 Web 界面供使用；<br><code>Codis-Proxy</code>是一个兼容 Redis 协议的无状态代理；<br><code>Codis-Redis</code>基于 <code>Redis 2.8 版本</code>二次开发，加入 <code>slot</code> 支持，方便迁移数据。</p><ul><li>优点：<ul><li>开发简单，对应用几乎透明；</li><li>性能比 <code>Twemproxy</code> 好；</li><li>有图形化界面，扩容容易，运维方便。</li></ul></li><li>缺点：<ul><li>代理依旧影响性能；</li><li>组件过多，需要很多机器资源；</li><li>修改了 Redis 代码，导致和官方无法同步，新特性跟进缓慢；</li><li>开发团队准备主推基于 Redis 改造的 <code>reborndb</code>。</li></ul></li></ul><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>Redis集群方案是一种<code>高可用</code>、<code>可扩展</code>的解决方案，通过<code>分片</code>和<code>主从复制</code>机制来实现数据的<code>分布式存储</code>和<code>故障转移</code>。</p><p>它具有以下<code>优点</code>：</p><ul><li>高可用：多个主节点，每个主节点有对应多个从节点，主节点宕机Redis Cluster机制会<code>自动</code>将某个从节点<code>切换</code>到主节点；</li><li>扩展性：<ul><li>横向扩展：通过增加机器实现增加能力上限；</li><li>读写扩展：基于主从模式，通过读写分离，增加读写能力，避免单点故障；</li><li>分布式存储：Redis Cluster采用<code>分片技术</code>将数据均匀分布到多个节点上，每个节点只保存部分数据，避免了单个节点存储数据过大的问题，提高了存储容量和性能。</li></ul></li><li>自动数据迁移：Redis Cluster支持<code>自动数据迁移</code>，当新增或删除节点时，会自动将数据迁移到其他节点上，保证数据均衡和数据完整性。</li></ul><p><code>缺点</code>也有很多：</p><ul><li>部署和管理复杂：Redis集群方案需要部署多个节点，并且需要进行一些配置和管理工作，例如设置节点数量、槽的分配、主从复制等。</li><li>可能存在数据丢失：由于Redis集群方案使用<code>异步复制</code>机制，当主节点宕机时，可能存在一段时间内的数据丢失。因此，在数据可靠性要求较高的场景中，需要进行备份和恢复等措施。</li><li>不支持事务：由于Redis集群方案中不同的节点存储着不同的数据，因此<code>不支持事务操作</code>。如果需要进行事务处理，可以使用Redis单节点方案。</li></ul><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h1><ul><li><a target="_blank" rel="noopener" href="https://www.linuxprobe.com/redis-high-availability.html">Redis高可用性实践</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2b5c9efdfea6">Redis Cluster 实现</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7226710109585834040">集群系列：Redis集群方案及新版实战</a></li><li><sup><a href="#fn_1" id="reffn_1">1</a></sup> <a target="_blank" rel="noopener" href="https://github.com/redis/redis/issues/2576">为什么是16384个哈希槽？</a></li><li><sup><a href="#fn_2" id="reffn_2">2</a></sup> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lpfuture/p/5796398.html">一致性哈希算法原理</a></li><li><sup><a href="#fn_3" id="reffn_3">3</a></sup> <a target="_blank" rel="noopener" href="https://juejin.cn/post/7226710109585834040#heading-22">RedisCluster通信协议</a></li></ul></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Kezade</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://zyxelva.github.io/posts/2973021972.html">https://zyxelva.github.io/posts/2973021972.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Kezade</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a> <a href="/tags/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"><span class="chip bg-color">集群模式</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.twikoo-card{margin:1.5rem auto}.twikoo-card .card-content{padding:20px}#tcomments textarea{box-sizing:border-box;background:url("/") 100% 100% no-repeat}#tcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem;text-align:left}#tcomments blockquote p{text-indent:.2rem}#tcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#tcomments img{max-width:100%;height:auto;cursor:pointer}#tcomments ol li{list-style-type:decimal}#tcomments ol,ul{display:block;padding-left:2em;word-spacing:0.05rem}#tcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#tcomments ul li{list-style-type:disc}#tcomments ul ul li{list-style-type:circle}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#tcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#tcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#tcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#tcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#tcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#tcomments h6{font-size:1rem;line-height:1.3rem}#tcomments p{font-size:1rem;line-height:1.5rem}#tcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#tcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#tcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#tcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#tcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#tcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#tcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#tcomments b,strong{font-weight:700}#tcomments dfn{font-style:italic}#tcomments small{font-size:85%}#tcomments cite{font-style:normal}#tcomments mark{background-color:#fcf8e3;padding:.2em}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card twikoo-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div class="card-content" style="display:grid"><div id="tcomments"></div></div></div><script src="https://gcore.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://kezadetwikoo.netlify.app/.netlify/functions/twikoo",el:"#tcomments",region:"",path:""}).then(function(){for(var t=document.querySelector("#twikoo").getElementsByTagName("input"),e=0;e<t.length;e++)t[e]&&t[e].classList.add("browser-default")})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/3918025932.html"><div class="card-image"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/featureimages/20.jpg" class="responsive-img" alt="【Redis学习】6.理解内存"> <span class="card-title">【Redis学习】6.理解内存</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-09-06</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis%E5%AD%A6%E4%B9%A0/" class="post-category">Redis学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a> <a href="/tags/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><span class="chip bg-color">内存结构</span></a> <a href="/tags/%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"><span class="chip bg-color">回收策略</span></a> <a href="/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"><span class="chip bg-color">内存优化</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/1235835282.html"><div class="card-image"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/featureimages/20.jpg" class="responsive-img" alt="【Redis学习】4.高可用之Sentinel"> <span class="card-title">【Redis学习】4.高可用之Sentinel</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-08-30</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis%E5%AD%A6%E4%B9%A0/" class="post-category">Redis学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a> <a href="/tags/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"><span class="chip bg-color">哨兵模式</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: Kezade<br />文章作者: Kezade<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeBlockFuction.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeLang.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeCopy.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h1, h2, h3, h4, h5"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const o="expanded";let n=$("#toc-aside"),i=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){n.hasClass(o)?(n.removeClass(o).hide(),i.removeClass("l9")):(n.addClass(o).show(),i.addClass("l9")),function(t,e){let o=$("#"+t);if(0===o.length)return;let n=o.width();n+=n>=450?21:n>=350&&n<450?18:n>=300&&n<350?16:14,$("#"+e).width(n)}("artDetail","prenext-posts")})})</script></main><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <a href="/about" target="_blank">Kezade</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=6e4,t=36e5,n=864e5,a=365*n,i=new Date,r="2019",o=i.getFullYear(),s=i.getMonth()+1,l=i.getDate(),m=i.getHours(),c=i.getMinutes(),d=i.getSeconds(),g=Date.UTC(r,"6","28","0","0","0"),h=Date.UTC(o,s,l,m,c,d)-g,u=Math.floor(h/a),M=Math.floor(h/n-365*u),T=Math.floor((h-(365*u+M)*n)/t),f=Math.floor((h-(365*u+M)*n-T*t)/e),y=Math.floor((h-(365*u+M)*n-T*t-f*e)/1e3);if(r===String(o)){document.getElementById("year").innerHTML=o;var v="This site has been running for "+M+" days";v="本站已运行 "+M+" 天",document.getElementById("sitetime").innerHTML=v}else{document.getElementById("year").innerHTML=r+" - "+o;var H="This site has been running for "+u+" years and "+M+" days "+T+" hours "+f+" mins "+y+" seconds";H="本站已苟且偷生 "+u+" 年 "+M+" 天 "+T+" 小时 "+f+" 分钟 "+y+" 秒",document.getElementById("sitetime").innerHTML=H}};calcSiteTime(),setInterval(calcSiteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/zyxelva" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:zyxelva@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1807401971" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1807401971" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a> <a href="https://www.zhihu.com/people/kezade" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kezade" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="../rss2.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach(function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach(function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))}),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach(function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")}),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}}),t+="</ul>",s.innerHTML=t)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/masonry/masonry.pkgd.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/js/matery.js"></script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/background/ribbon-dynamic.js" async></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/instantpage/instantpage.js" type="module"></script></body></html>