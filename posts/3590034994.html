<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="【MySQL学习】8.事务原理与MVCC, Back-End Dev Java"><meta name="description" content="1 实现机制WAL（Write-ahead logging，预写式日志）机制。
在使用 WAL 的系统中，所有的修改都先被写入到日志中，然后再被应用到系统中。通常包含 redo 和 undo 两部分信息。WAL机制

这两个日志都是 Inn"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>【MySQL学习】8.事务原理与MVCC | Kezade</title><link rel="icon" type="image/jpeg" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg"><style>body{background-image:url(https://it-ark-dev.oss-cn-shenzhen.aliyuncs.com/464e9ac7a5a729ae67f91f7cf0cf6fe2.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:cover;background-position:center center}</style><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/animate/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.1/css/matery.css?v3"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/my.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/post.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/reward.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/jquery/jquery-3.6.0.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.3/js/function.js?v88"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/imgStatus.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/waterfall.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/lately.min.js"></script><script>var memos={host:"https://s.dusays.com/",limit:"10",creatorId:"49",username:"zyxelva",name:"Kezade",domId:"#memos",path:"api/v1/memo"},douban={api:"https://douban-api.edui.fun/"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="Kezade" type="application/rss+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img k-avatar" alt="LOGO"> <span class="logo-span">Kezade</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-newspaper" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:0.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-sitemap" style="zoom:0.6"></i> <span>系列</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/categories/%E7%AE%97%E6%B3%95"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>考研</span></a></li><li><a href="/categories/OSSD"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>高考</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-place-of-worship" style="zoom:0.6"></i> <span>我的</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:0.6"></i> <span>相册</span></a></li><li><a href="/bibi"><i class="fa-fw fa-solid fa-cloud-rain" style="margin-top:-20px;zoom:0.6"></i> <span>哔哔</span></a></li><li><a href="/todolist"><i class="fa-fw fa-solid fa-circle-check" style="margin-top:-20px;zoom:0.6"></i> <span>清单</span></a></li><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:0.6"></i> <span>音乐</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-circle-info" style="zoom:0.6"></i> <span>更多</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:0.6"></i> <span>留言</span></a></li><li><a href="/friends"><i class="fa-solid fa-link" style="margin-top:-20px;zoom:0.6"></i> <span>友链</span></a></li><li><a href="/friend-circle"><i class="fa-solid fa-rss" style="margin-top:-20px;zoom:0.6"></i> <span>圈圈</span></a></li><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:0.6"></i> <span>关于</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img circle responsive-img"><div class="logo-name">Kezade</div><div class="logo-desc">7 年 Java 开发经验，其中 3 年以上大型系统架构设计经验，以及 2 年以上的团队管理经验 | 具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验 | 对 Zookeeper、Netty、Dubbo、Spring Cloud、 Spring 等开源框架源码有过深入研究，并且有一定的框架定制开发经验</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-newspaper"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-sitemap"></i> 系列<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/categories/%E7%AE%97%E6%B3%95" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>考研</span></a></li><li><a href="/categories/OSSD" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>高考</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-place-of-worship"></i> 我的<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/bibi" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-cloud-rain" style="position:absolute;left:50px"></i> <span>哔哔</span></a></li><li><a href="/todolist" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-circle-check" style="position:absolute;left:50px"></i> <span>清单</span></a></li><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-circle-info"></i> 更多<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="/friends" style="margin-left:75px"><i class="fa fa-solid fa-link" style="position:absolute;left:50px"></i> <span>友链</span></a></li><li><a href="/friend-circle" style="margin-left:75px"><i class="fa fa-solid fa-rss" style="position:absolute;left:50px"></i> <span>圈圈</span></a></li><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/cryptojs/crypto-js.min.js"></script><script></script><style>:root{--post-bg-image:url('https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/MySQL.jpeg')}</style><div class="bg-cover pd-header post-cover"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">【MySQL学习】8.事务原理与MVCC</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/MySQL/"><span class="chip bg-color">MySQL</span></a> <a href="/tags/MVCC/"><span class="chip bg-color">MVCC</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/" class="post-category">MySQL学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-06-19</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 8.5k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 31 分</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h1 id="1-实现机制"><a href="#1-实现机制" class="headerlink" title="1 实现机制"></a>1 实现机制</h1><p><code>WAL</code>（Write-ahead logging，预写式日志）机制。</p><p>在使用 <code>WAL</code> 的系统中，所有的修改都先被写入到<code>日志</code>中，然后再被应用到系统中。通常包含 <code>redo</code> 和 <code>undo</code> 两部分信息。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-WAL.png"></p><div class="caption"><b class="center-caption">WAL机制</b></div><p></p><blockquote><p>这两个日志都是 <code>InnoDB</code>存储引擎生成的。</p><h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2 redo log"></a>2 redo log</h1><p><code>重做日志</code>，每当有操作时，在数据变更之前将操作写入<code>redo log</code>，这样当发生<code>掉电</code>之类的情况时系统可以在重启后继续操作。在系统Crash重启之类的情况时修复数据（事务的持久性）。</p></blockquote><h2 id="2-1-日志格式（通用）"><a href="#2-1-日志格式（通用）" class="headerlink" title="2.1 日志格式（通用）"></a>2.1 日志格式（通用）</h2><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/redo-log.png"><div class="caption"><b class="center-caption">redo log 格式</b></div><ul><li><code>type</code>：该条<code>redo log</code>的类型，redo log 设计大约有<code>53种</code>不同的类型日志。</li><li><code>space ID</code>：表空间ID，但采用压缩的方式，因此占用的空间可能<code>小于4字节</code>。</li><li><code>page number</code>：页号或页的偏移量，同样采用压缩的方式。</li><li><code>data</code>：该条redo log的具体内容。</li></ul><blockquote><p>redo log 会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。</p></blockquote><h2 id="2-2-Mini-Transaction"><a href="#2-2-Mini-Transaction" class="headerlink" title="2.2 Mini-Transaction"></a>2.2 Mini-Transaction</h2><p>MySQL 把对底层页面中的<code>一次原子访问</code>的过程称之为一个<code>Mini-Transaction</code>，比如修改一次<code>Max Row ID</code> 的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+树</code>中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。</p><ul><li>可以包含一组<code>redo log</code>，在进行<code>崩溃恢复</code>时这一组redo log作为一个<code>不可分割</code>的整体；</li><li>一个事务可以包含若干条语句，每一条语句其实是由<code>若干个Mini-Transaction</code>组成，每一个<code>Mini-Transaction</code>又可以包含若干条<code>redo log</code>，最终形成了一个<code>树形结构</code>。</li></ul><h2 id="2-3-写入过程"><a href="#2-3-写入过程" class="headerlink" title="2.3 写入过程"></a>2.3 写入过程</h2><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/redo-log-writing-flow.png"><div class="caption"><b class="center-caption">redo log写入过程</b></div><blockquote><p>从重做日志缓冲（redo log buffer）往磁盘写入时，是按<code>512个字节</code>，也就是一个扇区的大小进行写入。因为<code>扇区</code>是写入的<code>最小单位</code>，因此可以保证写入<code>必定是成功的</code>。因此在重做日志的写入过程中<strong>不需要</strong>有<code>doublewrite</code>。</p></blockquote><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-redo-log-persistent.jpg"><div class="caption"><b class="center-caption">redo log持久化过程</b></div><h3 id="2-3-1-redo-log-buffer"><a href="#2-3-1-redo-log-buffer" class="headerlink" title="2.3.1 redo log buffer"></a>2.3.1 redo log buffer</h3><p>InnoDB 为了更好的进行系统崩溃恢复，把通过 <code>Mini-Transaction</code> 生成的 redo log都放在了大小为 <code>512 字节</code>的<code>块(block)</code>中。</p><ul><li>为了解决<code>磁盘速度过慢的问题</code>而引入了<code>Buffer Pool</code>。同理，写入<code>redo log</code>时也<code>不能直接写</code>到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，我们也可以简称为<code>log buffer</code>。这片内存空间被划分成<strong>若干个连续的</strong><code>redo log block</code>，我们可以通过启动参数 <code>innodb_log_buffer_size</code> 来指定 log buffer 的大小，该启动参数的默认值为 <code>16MB</code>。</li><li>顺序写：先往前边的<code>block</code>中写，当该<code>block</code>的空闲空间用完之后再往<code>下一个block</code>中写。</li><li><strong>并不是</strong>每生成一条<code>redo log</code>，就将其插入到<code>log buffer</code>中，而是每个<code>Mini-Transaction</code>运行过程中产生的日志先<code>暂存</code>到一个地方，当该<code>Mini-Transaction</code><strong>结束</strong>的时候，将过程中产生的一组<code>redo log</code>再<strong>全部复制</strong>到<code>log buffer</code>中。</li></ul><h3 id="2-3-2-redo-log刷盘"><a href="#2-3-2-redo-log刷盘" class="headerlink" title="2.3.2 redo log刷盘"></a>2.3.2 redo log刷盘</h3><p>上一章节里有提到日志刷盘的参数及其各自意思。这里只列举下集中刷盘的场景：</p><ul><li>log buffer 空间不足时，<code>log buffer</code> 的大小是有限的(通过系统变量 <code>innodb_log_buffer_size</code> 指定)，如果不停的往这个有限大小的 <code>log buffer</code>里塞入日志，很快它就会被填满。InnoDB 认为如果当前写入 <code>log buffer</code> 的 redo log量已经占满了 <code>log buffer 总容量</code>的<code>大约一半</code>左右，就需要把这些日志刷新到磁盘上。</li><li>事务提交时，之所以使用 redo log主要是因为它<code>占用的空间少</code>，还是<code>顺序写</code>，在事务提交时可以不把修改过的 Buffer Pool 页面刷新到磁盘， 但是为了保证<code>持久性</code>，必须要把修改这些页面对应的 redo log刷新到磁盘。</li><li>后台有一个线程，大约每秒都会刷新一次 log buffer 中的 redo log到磁盘。</li><li>正常关闭服务器时等等。</li></ul><h3 id="2-3-3-redo-log文件组"><a href="#2-3-3-redo-log文件组" class="headerlink" title="2.3.3 redo log文件组"></a>2.3.3 redo log文件组</h3><p>磁盘默认文件名 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。<code>log buffer</code> 中的日志默认情况下就是刷新到这两个<code>磁盘文件</code>中。如果我们对默认的 redo log文件不满意，可以通过下边几个启动参数来调节：</p><ul><li><code>innodb_log_group_home_dir</code>，该参数指定了 redo log文件所在的目录，<code>默认值就是当前的数据目录</code>。</li><li><code>innodb_log_file_size</code>， 该参数指定了每个 redo log文件的大小，<code>默认值为 48MB</code>，</li><li><code>innodb_log_files_in_group</code>，该参数指定 redo log文件的个数，<code>默认值为 2</code>， <code>最大值为 100</code>。</li></ul><p>所以磁盘上的 redo log文件可以<code>不只一个</code>，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>(数字可以是0、1、2…)的形式进行命名。</p><p>在将 redo log写入日志文件组时，是从 <code>ib_logfile0</code> 开始写，如果 <code>ib_logfile0</code> 写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。</p><p>如果写到最后一个文件该咋办？那就<code>重新转到ib_logfile0继续写</code>。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/writing-type.png"></p><div class="caption"><b class="center-caption">写入形式：大小固定，循环写入</b></div><p></p><pre class="line-numbers language-none"><code class="language-none">说明：
write pos：表示redo log当前记录的LSN(逻辑序列号)位置。
check point：表示「数据页更改记录」刷盘后对应redo log所处的LSN(逻辑序列号)位置。
write pos到check point之间的部分是redo log空着的部分，用于记录新的记录。
check point到write pos之间是redo log待落盘的数据页更改记录。
当write pos追上check point时，会先推动check point向前移动，空出位置再记录新的日志。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-4-redo-log文件格式"><a href="#2-3-4-redo-log文件格式" class="headerlink" title="2.3.4 redo log文件格式"></a>2.3.4 redo log文件格式</h3><ul><li>由若干个<code>512字节</code>大小的<code>block</code>组成。</li><li><code>前2048个字节</code>，也就是<code>前4个block</code>是用来存储一些<code>管理信息</code>的。</li><li><code>从第2048字节往后</code>是用来存储<code>log buffer</code>中的<code>block镜像</code>的。</li></ul><h2 id="2-4-Log-Sequence-Number"><a href="#2-4-Log-Sequence-Number" class="headerlink" title="2.4 Log Sequence Number"></a>2.4 Log Sequence Number</h2><p>每一组由<code>Mini-Transaction</code>生成的redo log都有一个<strong>唯一的LSN值</strong>与其对应，LSN值<code>越小</code>，说明redo log产生的<code>越早</code>。</p><p>规定初始的 LSN 值为 <code>8704</code>(也就是一条 redo log也没写入时，LSN的值为8704)。</p><h2 id="2-5-崩溃后的恢复"><a href="#2-5-崩溃后的恢复" class="headerlink" title="2.5 崩溃后的恢复"></a>2.5 崩溃后的恢复</h2><h3 id="2-5-1-恢复机制"><a href="#2-5-1-恢复机制" class="headerlink" title="2.5.1 恢复机制"></a>2.5.1 恢复机制</h3><p>关键词：LSN hash 槽 页恢复</p><ul><li>MySQL 可以根据 redo log中的各种 <code>LSN</code> 值，来确定<code>恢复的起点和终点</code>。然后将 redo log中的数据，以<code>哈希表</code>的形式，将一个页面下的放到哈希表的一个<code>槽</code>中。</li><li>之后就可以遍历<code>哈希表</code>，因为对同一个页面进行修改的 redo log都放在了一个槽里，所以可以一次性将一个页面修复好(避免了很多读取页面的随机IO)。并且通过各种机制，避免无谓的页面修复，比如已经刷新的页面，进而提升崩溃恢复的速度。</li></ul><h3 id="2-5-2-崩溃后的恢复为什么不用-binlog"><a href="#2-5-2-崩溃后的恢复为什么不用-binlog" class="headerlink" title="2.5.2 崩溃后的恢复为什么不用 binlog?"></a>2.5.2 崩溃后的恢复为什么不用 binlog?</h3><div class="table-container"><table><thead><tr><th>-</th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>作用不同</td><td>MySQL自己使用，用于保证在数据库崩溃时的<code>事务持久性</code></td><td>用作主从复制、人工恢复数据，如：<code>误删数据恢复</code></td></tr><tr><td>层次不同</td><td>是<code>InnoDB引擎</code>特有的</td><td>是MySQL 的<code>Server</code>层实现的，<code>所有引擎</code>都可以使用</td></tr><tr><td>内容不同</td><td><code>物理日志</code>，记录的是<code>在某个数据页上做了什么修改</code>，<code>恢复的速度更快</code></td><td><code>逻辑日志</code>，记录的是这个语句的原始逻辑，比如<code>给ID=2这的c 字段加1</code></td></tr><tr><td>写入时机不同</td><td>写入时机有三种（具体在上文中有介绍）</td><td>在事务提交完成后进行一次写入</td></tr><tr><td>写入方式不同</td><td><code>循环写</code>的日志文件，redo log只会记录<code>未刷盘的日志</code>，已经刷入磁盘的数据都会从redo log这个有限大小的日志文件里删除</td><td><code>追加日志</code>，保存的是<code>全量的日志</code></td></tr></tbody></table></div><blockquote><p>当数据库crash 后，想要恢复<code>未刷盘</code>但已经写入redo log 和binlog 的数据到内存时，binlog 是无法恢复的，但redo log 不一样，只要刷入磁盘的数据，都会从redo log 中抹掉，数据库重启后，直接把redo log 中的数据都恢复至内存就可以了.</p><p>binlog是【用于时间点恢复】的，保证服务器可以<code>基于时间点恢复数据</code>或者用于<code>主从复制</code>;</p><p>redo log是用于【崩溃恢复】.</p></blockquote><h1 id="3-binlog"><a href="#3-binlog" class="headerlink" title="3 binlog"></a>3 binlog</h1><p>文章开头说道，<code>redo log</code>和<code>undo log</code>这两个日志都是 <code>InnoDB 存储引擎</code>生成的，属于InnoDB存储引擎特有。而<code>binlog</code>属于MySQL Server层，所有引擎均可使用。</p><h2 id="3-1-为什么需要-binlog？"><a href="#3-1-为什么需要-binlog？" class="headerlink" title="3.1 为什么需要 binlog？"></a>3.1 为什么需要 binlog？</h2><p><code>binlog</code>文件是记录了<strong>所有数据库表结构变更和表数据修改的日志</strong>，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。早期的MySQL版本是没有InnoDB这个存储引擎的，MySQL自带的引擎是<code>MyISAM</code>，但是 MyISAM <code>没有 crash-safe 的能力</code>，<code>binlog</code>日志只能用于<code>归档</code>。后来版本加入InnoDB后，利用<code>redo log</code>实现了<code>crash-safe</code>的能力。</p><p>两者的区别，上一小节已经列举，参见2.5.2节。</p><h2 id="3-2-binlog文件是如何刷入磁盘的？"><a href="#3-2-binlog文件是如何刷入磁盘的？" class="headerlink" title="3.2 binlog文件是如何刷入磁盘的？"></a>3.2 binlog文件是如何刷入磁盘的？</h2><p>通过参数<code>sync_binlog</code>来设定，默认为0，各个值的意义如下表所示：</p><div class="table-container"><table><thead><tr><th>值</th><th>描述</th><th>特点</th></tr></thead><tbody><tr><td>0</td><td>每次提交事务都只 <code>write</code>，不 <code>fsync</code>，后续交由<strong>操作系统决定</strong>何时将数据<code>持久化</code>到磁盘；</td><td>性能最好，一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</td></tr><tr><td>1</td><td>每次提交事务都会 <code>write</code>，然后马上执行 <code>fsync</code>；</td><td>最安全但是性能损耗最大。</td></tr><tr><td>N(N&gt;1)</td><td>每次提交事务都 write，但累积 <code>N</code> 个事务后才 <code>fsync</code>。</td><td>能容忍少量事务的binlog日志丢失的风险，兼顾写入性能，一般设置<code>100~1000</code>中的某个值。</td></tr></tbody></table></div><h2 id="3-3-binlog文件格式"><a href="#3-3-binlog文件格式" class="headerlink" title="3.3 binlog文件格式"></a>3.3 binlog文件格式</h2><p>binlog 有 <code>3</code> 种格式类型，分别是 <code>STATEMENT</code>（默认格式）、<code>ROW</code>、 <code>MIXED</code>。</p><ul><li><code>STATEMENT</code>：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现；<ul><li>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，从而提高了性能；</li><li>缺点：动态函数的问题，比如你用了 <code>uuid</code> 或者 <code>now</code> 这些函数，你在<code>主库</code>上执行的结果并不是你在<code>从库</code>执行的结果，这种随时在变的函数会导致复制的<code>数据不一致</code>；</li></ul></li><li><code>ROW</code>：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。<ul><li>优点：<code>不会出现</code>某些特定情况下的<code>存储过程</code>、或 <code>function</code>、或 <code>trigger</code> 的调用和触发<strong>无法被正确复制的问题</strong>；</li><li>缺点：<code>每行数据</code>的变化结果都会被记录，比如执行批量 <code>update</code> 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 <code>STATEMENT</code> 格式下只会记录<code>一个 update 语句</code>而已；</li></ul></li><li><code>MIXED</code>：包含了 <code>STATEMENT</code> 和 <code>ROW</code> 模式，它会根据不同的情况自动使用 <code>ROW</code> 模式和 <code>STATEMENT</code> 模式；</li></ul><h2 id="3-4-写入了什么数据？"><a href="#3-4-写入了什么数据？" class="headerlink" title="3.4 写入了什么数据？"></a>3.4 写入了什么数据？</h2><p>MySQL 在<code>提交事务</code>的时候，不仅仅会将 <code>redo log buffer</code> 中的数据写入到<code>redo log</code>文件中，同时也会将本次修改的数据记录到 <code>binlog文件</code>中，同时会将本次修改的<code>binlog文件名</code>和<code>修改的内容在binlog中的位置</code>记录到<code>redo log</code>中，最后还会在<code>redo log</code>最后写入<code>commit 标记</code>，这样就表示本次事务被成功地提交了。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-binlog-flow.png"><div class="caption"><b class="center-caption">binlog写入过程示意图</b></div><h2 id="3-5-主从复制是怎么实现？"><a href="#3-5-主从复制是怎么实现？" class="headerlink" title="3.5 主从复制是怎么实现？"></a>3.5 主从复制是怎么实现？</h2><p>MySQL 的<code>主从复制</code>依赖于 <code>binlog</code> ，也就是记录 MySQL 上的所有变化并以<code>二进制</code>形式保存在磁盘上。复制的过程就是将 <code>binlog</code> 中的数据从<code>主库</code>传输到<code>从库</code>上。</p><p>这个过程一般是<code>异步的</code>，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-Master-Slave-Replication.jpg"><div class="caption"><b class="center-caption">主从复制过程示意图</b></div><p>具体详细过程如下：</p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 <code>I/O 线程</code>，连接主库的 <code>log dump 线程</code>，来接收主库的 binlog 日志，再把 binlog 信息写入 <code>relay log</code>(中继日志)里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的<code>SQL线程</code>，去读 <code>relay log</code>中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-Read-Write-Dispatch.jpg"><div class="caption"><b class="center-caption">主从结构的读写分离模型</b></div><blockquote><p>并不是从库越多越好，随着从库数量的增加，从库连接上来的 <code>I/O 线程</code>也比较多，主库也要创建同样多的 <code>log dump 线程</code>来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。</p><p>一般情况下，一个主库一般跟 <code>2～3</code> 个从库（1 套数据库，1 主 2 从 1 备主）。</p><p>MySQL 主从复制还有哪些模型？</p></blockquote><p>主要有三种：</p><ul><li><code>同步复制</code>：MySQL 主库提交事务的线程要<strong>等待所有从库的复制成功响应</strong>，才返回客户端结果。<ul><li>缺点：一是<code>性能很差</code>，因为要复制到所有节点才返回响应；二是<code>可用性也很差</code>，主库和所有从库任何一个数据库出问题，都会影响业务。</li></ul></li><li><code>异步复制</code>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各个从库，就返回客户端结果。<ul><li>缺点：这种模式一旦主库宕机，数据就会发生丢失。</li></ul></li><li><code>半同步复制</code>：<code>MySQL 5.7</code> 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要<code>一部分复制成功响应</code>回来就行，比如一主二从的集群，只要数据成功复制到<code>任意一个</code>从库上，主库的事务线程就可以返回给客户端。<ul><li>优点：这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</li></ul></li></ul><h2 id="3-6-两阶段提交"><a href="#3-6-两阶段提交" class="headerlink" title="3.6 两阶段提交"></a>3.6 两阶段提交</h2><p>事务提交后，<code>redo log</code> 和 <code>binlog</code> 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了<code>「两阶段提交」</code>来解决，两阶段提交其实是<code>分布式事务一致性协议</code>，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><code>两阶段提交</code>分为两个部分：</p><ul><li><code>prepare阶段</code>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 <code>prepare</code>，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li><li><code>commit阶段</code>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 <code>commit</code>，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功。</li></ul><p>将3.4节的图简化下，如下所示：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-binlog-2pc.png"></p><div class="caption"><b class="center-caption">两阶段提交示意图</b></div><p></p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/MySQL-binlog-2pc3.jpg"><div class="caption"><b class="center-caption">两阶段提交异常情况示意图</b></div><p>异常情况：</p><ul><li>如果在写入<code>redo log</code><strong>之前</strong>崩溃，那么此时<code>redo log</code>与<code>binlog</code>中都没有，是一致的情况，崩溃也无所谓。</li><li>如果在写入redo log <code>prepare阶段</code>后立马崩溃，之后会在崩溃恢复时，由于<code>redo log</code><strong>没有被标记为commit</strong>。于是拿着<code>redo log</code>中的<code>XID</code>去<code>binlog</code>中查找，此时肯定是找不到的，那么执行<code>回滚</code>操作；</li><li>如果在写入<code>binlog</code>后立马崩溃，在恢复时，由于<code>redo log</code>中的<code>XID</code>可以找到对应的<code>binlog</code>，这个时候直接<code>提交</code>即可。</li></ul><blockquote><p>总的来说，在崩溃恢复后，只要redo log不是处于commit阶段，那么就拿着redo log中的XID去binlog中寻找，找得到就提交，否则就回滚。</p><p>事务没提交的时候，redo log 也是可能被持久化到磁盘的.</p><p>两阶段提交有什么问题？</p></blockquote><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是<code>性能很差</code>，主要有两个方面的影响：</p><ul><li>磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li>锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><p>解决方案：参见<a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">组提交</a>.</p><h1 id="4-undo-log"><a href="#4-undo-log" class="headerlink" title="4 undo log"></a>4 undo log</h1><p>每当我们要对一条记录做<code>改动</code>时(这里的改动可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)，都需要把回滚时所需的东西都给记下来。比方说:</p><ul><li>你<code>插入</code>一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录<strong>删掉</strong>。</li><li>你<code>删除</code>了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中。</li><li>你<code>修改</code>了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录<strong>更新</strong>为旧值。</li></ul><p>这些为了回滚而记录的这些东西称之为<code>撤销日志</code>，英文名为<code>undo log</code>。其作用就是：</p><blockquote><p>当一些变更执行到一半<code>无法完成</code>时，可以根据<code>撤销日志</code><strong>恢复</strong>到变更之前的状态。<br>保证ACID中的原子性(Atomic)。</p></blockquote><p>在事务没提交之前，MySQL 会先记录更新前的数据到<code>undo log</code>日志文件里面，当事务回滚时，可以利用<code>undo log</code>来进行回滚。如下图：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/tx-rollback.png"></p><div class="caption"><b class="center-caption">事务回滚流程</b></div><p></p><blockquote><p>在真实的 InnoDB 中，undo log其实并不像我们上边所说的那么简单，不同类型的操作产生的undo log的格式也是不同的。</p></blockquote><p>一条记录的每一次<code>更新</code>操作产生的 undo log 格式都有一个 <code>roll_pointer</code> 指针和一个 <code>trx_id</code> 事务id：</p><ul><li>通过 <code>trx_id</code> 可以知道该记录是被哪个事务修改的；</li><li>通过 <code>roll_pointer</code> 指针可以将这些 <code>undo log</code> 串成一个<code>链表</code>，这个链表就被称为<code>版本链</code>；</li></ul><blockquote><p>这是undo log又一重要作用，实现<code>MVCC</code>。</p></blockquote><h1 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h1><p>MVCC，即<code>multi-version concurrency control</code>，多版本并发控制。通过 <code>ReadView + undo log</code> 实现。undo log 为每条记录保存多份历史数据，MySQL 在执行<code>快照读</code>（普通 select 语句）的时候，会根据事务的 <code>Read View</code> 里的信息，顺着 <code>undo log</code> 的<code>版本链</code>找到满足其<code>可见性的记录</code>。</p><h2 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h2><p>要真正了解<code>MVCC</code>的原理，首先必须要了解<code>事务并发会产生哪些问题</code>以及<code>事务的隔离级别</code>。</p><p>在<a href="/posts/2568190957.html" title="【MySQL学习】2.事务和事务的隔离级别">【MySQL学习】2.事务和事务的隔离级别</a>，我已经理清了一遍。这里不再赘述。</p><h2 id="5-2-隐式字段"><a href="#5-2-隐式字段" class="headerlink" title="5.2 隐式字段"></a>5.2 隐式字段</h2><p>上一小节提到</p><blockquote><p>一条记录的每一次<code>更新</code>操作产生的 undo log 格式都有一个 <code>roll_pointer</code> 指针和一个 <code>trx_id</code> 事务id.</p></blockquote><p>对于数据库中的一条记录，其真实格式如下：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/hiden-rows-format.png"></p><div class="caption"><b class="center-caption">隐藏列</b></div><p></p><p>其中，<code>row_id</code>、<code>trx_id</code>、<code>roll_ptr</code>为三个隐藏字段。若某表已经定义了主键或者唯一索引，则无<code>row_id</code>。</p><div class="table-container"><table><thead><tr><th>隐藏字段</th><th>描述</th><th>是否必须</th></tr></thead><tbody><tr><td>row_id</td><td>隐藏主键，若表中无主键或唯一索引，则会生成一<code>单调递增</code>的行ID作为<code>聚簇索引</code></td><td>否</td></tr><tr><td>trx_id</td><td>事务ID，也称事务版本号，占用6B，事务开始前，会从数据库中获得一自增长的事务ID，用以判断事务的执行顺序</td><td>是</td></tr><tr><td>roll_ptr</td><td>占用7B，回滚指针，指向当前记录的上一版本undo log，存储于回滚段中</td><td>是</td></tr></tbody></table></div><h2 id="5-3-版本链"><a href="#5-3-版本链" class="headerlink" title="5.3 版本链"></a>5.3 版本链</h2><p>假设，有这样一个表：<br><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> teacher
<span class="token punctuation">(</span>
    number <span class="token keyword">INT</span><span class="token punctuation">,</span>
    name   <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    domain <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">Engine</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span>
  <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8mb4<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>然后向这个表里插入一条数据：<br><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> teacher <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token string">'源码系列'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>假设插入该记录的<code>事务 id</code> 为 <code>60</code>，那么此刻该条记录的示意图如下所示：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/mvcc-record.png"></p><div class="caption"><b class="center-caption">一条记录</b></div><p></p><p>之后两个事务 id 分别为 <code>80</code>、<code>120</code> 的事务对这条记录进行 <code>UPDATE</code> 操作，操作流程如下：</p><div class="table-container"><table><thead><tr><th>Trx-80</th><th>Trx-120</th></tr></thead><tbody><tr><td>BEGIN</td><td></td></tr><tr><td></td><td>BEGIN</td></tr><tr><td>UPDATE teacher SET name = ‘Mark’ WHERE number = 1;</td><td></td></tr><tr><td>UPDATE teacher SET name = ‘James’ WHERE number = 1;</td><td></td></tr><tr><td>COMMIT</td><td></td></tr><tr><td></td><td>UPDATE teacher SET name = ‘King’ WHERE number = 1;</td></tr><tr><td></td><td>UPDATE teacher SET name = ‘大飞’ WHERE number = 1;</td></tr><tr><td></td><td>COMMIT</td></tr></tbody></table></div><p>每次对记录进行改动，都会记录一条 undo log，每条 undo log也都有一 个 <code>roll_pointer</code> 属性(<code>INSERT</code> 操作对应的 undo log<strong>没有</strong>该属性，因为该记录并<code>没有更早的版本</code>)，可以将这些 undo log都连起来，串成一个<code>链表</code>，所以现在的情况就像下图一样：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/mvcc-links.png"></p><div class="caption"><b class="center-caption">版本链</b></div><p></p><p>对该记录每次更新后，都会将<code>旧值</code>放到一条 undo log中，就算是该记录的一个<code>旧版本</code>，随着更新次数的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的<code>头节点</code>就是当前记录<code>最新</code>的值。另外，每个版本中还包含生成该版本时对应的事务 id。于是可以利用这个记录的<code>版本链</code>来控制<code>并发事务访问相同记录的行为</code>，那么这种机制就被称之为<code>多版本并发控制</code>(Mulit-Version Concurrency Control, MVCC)。</p><h2 id="5-4-ReadView"><a href="#5-4-ReadView" class="headerlink" title="5.4 ReadView"></a>5.4 ReadView</h2><p>MySQL中，有4种事务隔离级别，对于这几种级别，要实现快照读的下的并发控制，MySQL是这样处理的：</p><ul><li>对于使用 <code>READ UNCOMMITTED</code> 隔离级别的事务来说，由于可以读到<code>未提交</code>事务修改过的记录，所以直接读取记录的<code>最新版本</code>就好了。</li><li>对于使用 <code>SERIALIZABLE</code> 隔离级别的事务来说，InnoDB 使用<code>加锁</code>的方式来访问记录。</li><li>对于使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务来说，都必须保证读到<code>已经提交</code>了的事务修改过的记录。因此需要判断一下<code>版本链</code>中的哪个版本是<strong>当前事务</strong><code>可见的</code>。</li></ul><p>为此，InnoDB 提出了一个 <code>ReadView</code> 的概念，这个 <code>ReadView</code> 中主要包含 <code>4</code> 个比较重要的内容:</p><div class="table-container"><table><thead><tr><th>组成</th><th>描述</th></tr></thead><tbody><tr><td>creator_trx_id</td><td>创建当前read view的事务ID</td></tr><tr><td>m_ids</td><td>当前系统中<code>所有的活跃事务的 id</code>，活跃事务指的是当前系统中开启了事务，但还没有提交的事务</td></tr><tr><td>m_low_limit_id</td><td>表示在生成ReadView时，当前系统中<code>活跃的</code>读写事务中<code>最小的事务id</code>，即m_ids中的最小值</td></tr><tr><td>m_up_limit_id</td><td>当前系统中事务的 id 值最大的那个事务 id 值<code>再加 1</code>，也就是系统中<code>下一个要生成的事务 id</code></td></tr></tbody></table></div><p>有了这个 <code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本<code>是否可见</code>:</p><ul><li>如果被访问版本的 <code>trx_id == creator_trx_id</code> ， 意味着当前事务在访问它自己修改过的记录，所以该版本<code>可以被当前事务访问</code>；</li><li>如果被访问版本的 <code>trx_id &lt; min_trx_id</code> ，表明生成该版本的事务在<code>当前事务生成 ReadView 前</code><strong>已经提交</strong>，所以该版本<code>可以被当前事务访问</code>。</li><li>如果被访问版本的 <code>trx_id &gt;= max_trx_id</code>，表明生成该版本的事务在<code>当前事务生成 ReadView 后</code>才<strong>开启</strong>，所以该版本<code>不可以被当前事务访问</code>。</li><li>如果被访问版本的 <code>min_trx_id &lt; trx_id &lt; max_trx_id</code>，那就需要判断一下 <code>trx_id</code> 属性值<code>是不是在 m_ids 列表中</code>，如果在，说明创建 ReadView 时生成该版本的事务还是<code>活跃的</code>， 该版本<code>不可以被访问</code>；如果不在，说明创建 ReadView 时生成该版本的事务<code>已经被提交</code>，该版本<code>可以被访问</code>。</li><li>如果某个版本的数据对当前事务不可见的话，那就<code>顺着版本链</code>找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</li></ul><blockquote><p>在 MySQL 中，<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的一个非常大的区别就是它们<strong>生成 ReadView 的时机不同</strong>。</p><ul><li>READ COMMITTED：ReadView在事务后<code>每次select</code>都会重新生成；</li><li>REPEATABLE READ：ReadView在<code>第一次select</code>时生成，<code>事务操作期间不更新</code>。</li></ul></blockquote><p>以表 <code>teacher</code> 为例，假设现在表 <code>teacher</code> 中只有一条由事务 id 为 <code>60</code> 的事务插入的一条记录，如下表所示，接下来看一下 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 所谓的生成 <code>ReadView</code> 的时机不同到底不同在哪里。</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>源码系列</td></tr></tbody></table></div><h3 id="5-4-1-READ-COMMITTED"><a href="#5-4-1-READ-COMMITTED" class="headerlink" title="5.4.1 READ COMMITTED"></a>5.4.1 READ COMMITTED</h3><p>在<code>READ COMMITTED</code>隔离级别下，<code>每次读取数据前</code><strong>都生成</strong>一个新的<code>ReadView</code>。<br>现在系统里有两个事务 id 分别为 <code>80</code>、<code>120</code> 的事务在执行。</p><div class="table-container"><table><thead><tr><th>步骤</th><th>Trx-80</th><th>Trx-120</th><th>Trx-0</th></tr></thead><tbody><tr><td>p1</td><td>BEGIN</td><td></td><td></td></tr><tr><td>p2</td><td></td><td>BEGIN</td><td></td></tr><tr><td>p3</td><td>UPDATE teacher SET name = ‘Mark’ WHERE number = 1;</td><td></td><td></td></tr><tr><td>p4</td><td>UPDATE teacher SET name = ‘James’ WHERE number = 1;</td><td></td><td></td></tr><tr><td>p5</td><td></td><td></td><td>BEGIN</td></tr><tr><td>p6</td><td></td><td></td><td>SELECT * FROM teacher WHERE number = 1;</td></tr><tr><td>p7</td><td>COMMIT</td><td></td><td></td></tr><tr><td>p8</td><td></td><td>UPDATE teacher SET name = ‘King’ WHERE number = 1;</td><td></td></tr><tr><td>p9</td><td></td><td>UPDATE teacher SET name = ‘大飞’ WHERE number = 1;</td><td></td></tr><tr><td>p10</td><td></td><td></td><td>SELECT * FROM teacher WHERE number = 1;</td></tr><tr><td>p11</td><td></td><td>COMMIT</td></tr></tbody></table></div><p>执行完<code>p4</code>后，表 <code>teacher</code> 中 <code>number=1</code> 的记录得到的<code>版本链表</code>如下所示：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/trx80-mvcc.png"></p><div class="caption"><b class="center-caption">事务80下的版本链</b></div><p></p><p>在执行到步骤<code>p6</code>时，假定现在查询的事务id为<code>0</code>，得到的结果为：</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>源码系列</td></tr></tbody></table></div><p>现具体分析下为什么<code>name=Jack</code>。</p><p><code>p6</code>SQL语句执行过程如下：</p><ul><li>生成一个 <code>ReadView</code>，结果如下：</li></ul><div class="table-container"><table><thead><tr><th>组成</th><th>描述</th></tr></thead><tbody><tr><td>creator_trx_id</td><td>0</td></tr><tr><td>m_ids</td><td>[80, 120]</td></tr><tr><td>m_low_limit_id</td><td>80</td></tr><tr><td>m_up_limit_id</td><td>121</td></tr></tbody></table></div><ul><li>先分析版本链第一条记录，其<code>trx_id=80</code>，且位于活跃事务列表<code>m_ids</code>中，根据<code>5.4</code>节中，可见性判别规则第<code>4</code>条，对于当前查询事务id为0，不可见，根据 <code>roll_ptr</code> 跳到下一个版本；</li><li>下一个版本的列 <code>name=&#39;Mark&#39;</code>，该版本的 <code>trx_id=80</code>，也在 <code>m_ids</code> 列表内，所以也不符合要求，继续跳到下一个版本；</li><li>下一个版本的列 <code>name=&#39;Jack&#39;</code>，该版本的 <code>trx_id=60</code>，小于 ReadView 中的 <code>min_trx_id</code> 值，所以这个版本是符合要求的（<code>5.4</code>节中，可见性判别规则第<code>2</code>条），可见，最后返回给用户的版本就是这条列 <code>name=&#39;Jack&#39;</code>的记录。</li></ul><p>然后，将事务id <code>80</code>提交，对事务id <code>120</code>执行完<code>update</code>语句，然后分析下进行到步骤<code>p10</code>，可见性分析情况：<br>执行到步骤<code>p10</code>后，版本链情况：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/trx120-mvcc.png"></p><div class="caption"><b class="center-caption">事务120下的版本链</b></div><p></p><p>则事务id <code>0</code>查询得到的结果为：</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>James</td><td>源码系列</td></tr></tbody></table></div><p>在执行步骤<code>p10</code>当中的语句时又会<code>重新生成</code>一个<code>ReadView</code>，结果如下所示：</p><div class="table-container"><table><thead><tr><th>组成</th><th>描述</th></tr></thead><tbody><tr><td>creator_trx_id</td><td>0</td></tr><tr><td>m_ids</td><td>[120]</td></tr><tr><td>m_low_limit_id</td><td>120</td></tr><tr><td>m_up_limit_id</td><td>121</td></tr></tbody></table></div><ul><li>版本链第一条记录，<code>name=&#39;大飞&#39;</code>，<code>trx_id=120</code>，位于<code>m_ids</code>当中，不可见，根据 <code>roll_ptr</code> 跳到下一个版本；</li><li>该版本的列 <code>name=&#39;King&#39;</code>，该版本的 <code>trx_id=120</code>，也在 <code>m_ids</code> 列表内，所以也不符合要求，继续跳到下一个版本；</li><li>该版本<code>name=&#39;James&#39;</code>，<code>trx_id=80</code>，小于 <code>ReadView</code> 中的 <code>min_trx_id</code> 值 <code>120</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 <code>name=&#39;James&#39;</code>的记录。</li></ul><blockquote><p>总结：使用 <code>READ COMMITTED</code> 隔离级别的事务，在<strong>每次查询开始时都会生成一个新的、独立的 ReadView</strong>。</p></blockquote><h3 id="5-4-2-REPEATABLE-READ"><a href="#5-4-2-REPEATABLE-READ" class="headerlink" title="5.4.2 REPEATABLE READ"></a>5.4.2 REPEATABLE READ</h3><p>对于使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在<code>第一次执行查询语句</code>时生成一个 <code>ReadView</code>，之后的查询就<strong>不会重复生成</strong>了。</p><p>同样拿上一节中的例子，这次的查询事务为<code>REPEATABLE READ 隔离级别</code>下的，<code>id=1</code>。</p><p>在执行到步骤<code>p6</code>时，事务id为<code>80</code>、<code>120</code>均未提交，得到的结果为：</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>源码系列</td></tr></tbody></table></div><p>分析：</p><ul><li>在执行 <code>p6</code>中的SELECT 语句时，会先生成一个 <code>ReadView</code>，<code>ReadView</code> 结果如下：</li></ul><div class="table-container"><table><thead><tr><th>组成</th><th>描述</th></tr></thead><tbody><tr><td>creator_trx_id</td><td>1</td></tr><tr><td>m_ids</td><td>[80, 120]</td></tr><tr><td>m_low_limit_id</td><td>80</td></tr><tr><td>m_up_limit_id</td><td>121</td></tr></tbody></table></div><p>版本链与上节一样，为：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/trx80-mvcc.png"></p><div class="caption"><b class="center-caption">事务80下的版本链</b></div><p></p><ul><li>最新版本的列 <code>name=&#39;James&#39;</code>，该版本的 <code>trx_id=80</code>，在 <code>m_ids</code> 列表内，所以不符合可见性要求，根据 <code>roll_ptr</code> 跳到下一个版本；</li><li>下一个版本的列 <code>name=&#39;Mark&#39;</code>，该版本的 <code>trx_id=80</code>，也在 <code>m_ids</code> 列表内，所以也不符合要求，继续跳到下一个版本；</li><li>下一个版本的列 <code>name=&#39;Jack&#39;</code>，该版本的 <code>trx_id=60</code>，小于 <code>ReadView</code> 中的 <code>min_trx_id</code> 值，所以这个版本是<strong>符合要求的</strong>，最后返回给用户的 版本就是这条列 <code>name=&#39;Jack&#39;</code>的记录。</li></ul><p>然后，提交一下事务id为<code>80</code>的事务。</p><p>执行到步骤<code>p10</code>后，版本链情况同上节：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/trx120-mvcc.png"></p><div class="caption"><b class="center-caption">事务120下的版本链</b></div><p></p><p>则事务id <code>1</code>查询得到的结果为：</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>源码系列</td></tr></tbody></table></div><p>在执行步骤<code>p10</code>当中的语句时<strong>不会</strong><code>重新生成</code>一个<code>ReadView</code>，仍然是步骤<code>p6</code>时的结果：</p><div class="table-container"><table><thead><tr><th>组成</th><th>描述</th></tr></thead><tbody><tr><td>creator_trx_id</td><td>1</td></tr><tr><td>m_ids</td><td>[80, 120]</td></tr><tr><td>m_low_limit_id</td><td>80</td></tr><tr><td>m_up_limit_id</td><td>121</td></tr></tbody></table></div><p>执行过程分析类似，这里不再赘述。两次 <code>SELECT</code> 查询得到的结果是<code>重复的</code>，记录的列 <code>name</code> 值都是<code>Jack</code>， 这就是<code>可重复读</code>的含义。如果我们之后再把事务 id 为 <code>120</code> 的记录提交了，然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个 <code>number=1</code> 的记录，得到的结果还是’Jack’。</p><blockquote><p>总结：使用 <code>REPEATABLE READ</code> 隔离级别的事务，在<strong>在第一次读取数据时生成一个 ReadView</strong>。</p></blockquote><h2 id="5-5-MVCC-下的幻读解决"><a href="#5-5-MVCC-下的幻读解决" class="headerlink" title="5.5 MVCC 下的幻读解决"></a>5.5 MVCC 下的幻读解决</h2><p><code>REPEATABLE READ</code> 隔离级别下 <code>MVCC</code> 可以解决<code>不可重复读问题</code>，那么<code>幻读</code>呢？<code>MVCC</code> 是怎么解决的？</p><p><code>幻读</code>是一个事务按照某个<code>相同条件</code><strong>多次</strong>读取记录时，<code>后读取</code>时读到了<code>之前没有读到的记录</code>，而这个记录来自另一个事务添加的新记录。</p><p>在 <code>REPEATABLE READ</code> 隔离级别下的事务 <code>T1</code> 先根据某个搜索条件读取到多条记录，然后事务 <code>T2</code> 插入一条<code>符合相应搜索条件</code>的记录并<code>提交</code>， 然后事务 <code>T1</code> 再根据相同搜索条件执行查询。结果会是什么？<br>按照 <code>ReadView</code> 中的比较规则:</p><ul><li>如果被访问版本的 <code>trx_id &gt;= max_trx_id</code> 值，表明生成该版本的事务在<code>当前事务生成 ReadView 后</code>才开启，所以该版本<code>不可以被当前事务访问</code>。</li><li>如果被访问版本的 <code>min_trx_id &lt; trx_id &lt; max_trx_id</code>，那就需要判断一下 <code>trx_id</code> 属性值<code>是不是在 m_ids 列表中</code>，如果在，说明创建 <code>ReadView</code> 时生成该版本的事务还是<code>活跃的</code>， 该版本<code>不可以被访问</code>；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务<code>已经被提交</code>，该版本可以被访问。</li></ul><p>不管事务 <code>T2</code> 比事务 <code>T1</code> 是否先开启，事务 <code>T1</code> 都是<strong>看不到</strong> <code>T2</code> 的提交。</p><p>但是，在 <code>REPEATABLE READ</code> 隔离级别下 InnoDB 中的 <code>MVCC</code> 可以<code>很大程度地避免幻读现象</code>，<code>而不是完全禁止幻读</code>。怎么回事呢？我们来看下面的情况：</p><p>还是5.3节中的表<code>teacher</code>，目前拥有以下数据：</p><div class="table-container"><table><thead><tr><th>number</th><th>name</th><th>domain</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>源码系列</td></tr><tr><td>3</td><td>Mark</td><td>并发编程</td></tr><tr><td>9</td><td>James</td><td>Redis</td></tr><tr><td>15</td><td>King</td><td>JVM</td></tr><tr><td>21</td><td>Dafei</td><td>MySQL</td></tr></tbody></table></div><p>执行以下操作：</p><div class="table-container"><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>select * from teacher where number = 30;</td><td></td></tr><tr><td></td><td>Begin</td></tr><tr><td></td><td>insert into teacher values(30,’Luffy’,’ELK’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>update teacher set domain=’RabbitMQ’ where number=30;</td><td></td></tr><tr><td>select * from teacher where number = 30;</td></tr></tbody></table></div><p>结果如下：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/mvcc-phantom-read.png"></p><div class="caption"><b class="center-caption">幻读</b></div><p></p><p>咋回事儿？</p><p>在 REPEATABLE READ 隔离级别下，T1 第一次执行普通的 SELECT 语句时生成 了一个 ReadView，之后 T2 向 teacher 表中新插入一条记录并提交。</p><p><code>ReadView</code>并不能阻止<code>T1</code>执行<code>UPDATE</code>或者<code>DELETE</code>语句来改动这个新插入的记录(由于<code>T2</code>已经提交，因此改动该记录并不会造成阻塞)，但是这样一来，这条新记录的<code>trx_id</code>隐藏列的值就变成了<code>T1</code>的<code>事务id</code>。之后<code>T1</code>再使用<code>普通的SELECT语句</code>去查询这条记录时就<code>可以看到</code>这条记录了，也就可以把这条记录返回给客户端。</p><p>因为这个特殊现象的存在，我们也可以认为<code>MVCC</code><strong>并不能完全禁止幻读</strong>。</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Kezade</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://zyxelva.github.io/posts/3590034994.html">https://zyxelva.github.io/posts/3590034994.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Kezade</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/MySQL/"><span class="chip bg-color">MySQL</span></a> <a href="/tags/MVCC/"><span class="chip bg-color">MVCC</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.twikoo-card{margin:1.5rem auto}.twikoo-card .card-content{padding:20px}#tcomments textarea{box-sizing:border-box;background:url("/") 100% 100% no-repeat}#tcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem;text-align:left}#tcomments blockquote p{text-indent:.2rem}#tcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#tcomments img{max-width:100%;height:auto;cursor:pointer}#tcomments ol li{list-style-type:decimal}#tcomments ol,ul{display:block;padding-left:2em;word-spacing:0.05rem}#tcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#tcomments ul li{list-style-type:disc}#tcomments ul ul li{list-style-type:circle}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#tcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#tcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#tcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#tcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#tcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#tcomments h6{font-size:1rem;line-height:1.3rem}#tcomments p{font-size:1rem;line-height:1.5rem}#tcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#tcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#tcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#tcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#tcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#tcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#tcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#tcomments b,strong{font-weight:700}#tcomments dfn{font-style:italic}#tcomments small{font-size:85%}#tcomments cite{font-style:normal}#tcomments mark{background-color:#fcf8e3;padding:.2em}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card twikoo-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div class="card-content" style="display:grid"><div id="tcomments"></div></div></div><script src="https://gcore.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://kezadetwikoo.netlify.app/.netlify/functions/twikoo",el:"#tcomments",region:"",path:""}).then(function(){for(var t=document.querySelector("#twikoo").getElementsByTagName("input"),e=0;e<t.length;e++)t[e]&&t[e].classList.add("browser-default")})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/2971760749.html"><div class="card-image"><img src="/medias/hexo.png" class="responsive-img" alt="【Hexo】由CDN引发的暴躁场面"> <span class="card-title">【Hexo】由CDN引发的暴躁场面</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-06-20</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Hexo/" class="post-category">Hexo</a></span></div></div><div class="card-action article-tags"><a href="/tags/Hexo%E5%8D%9A%E5%AE%A2/"><span class="chip bg-color">Hexo博客</span></a> <a href="/tags/Hexo%E6%B3%A8%E5%85%A5%E5%99%A8/"><span class="chip bg-color">Hexo注入器</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/4004849283.html"><div class="card-image"><img src="/medias/MySQL.jpeg" class="responsive-img" alt="【MySQL学习】7.InnoDB 引擎底层解析"> <span class="card-title">【MySQL学习】7.InnoDB 引擎底层解析</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-06-15</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/MySQL%E5%AD%A6%E4%B9%A0/" class="post-category">MySQL学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/MySQL/"><span class="chip bg-color">MySQL</span></a> <a href="/tags/InnoDB/"><span class="chip bg-color">InnoDB</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: Kezade<br />文章作者: Kezade<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeBlockFuction.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeLang.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeCopy.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h1, h2, h3, h4, h5"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const o="expanded";let n=$("#toc-aside"),i=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){n.hasClass(o)?(n.removeClass(o).hide(),i.removeClass("l9")):(n.addClass(o).show(),i.addClass("l9")),function(t,e){let o=$("#"+t);if(0===o.length)return;let n=o.width();n+=n>=450?21:n>=350&&n<450?18:n>=300&&n<350?16:14,$("#"+e).width(n)}("artDetail","prenext-posts")})})</script></main><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <a href="/about" target="_blank">Kezade</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=6e4,t=36e5,n=864e5,a=365*n,i=new Date,r="2019",o=i.getFullYear(),s=i.getMonth()+1,l=i.getDate(),m=i.getHours(),c=i.getMinutes(),d=i.getSeconds(),g=Date.UTC(r,"6","28","0","0","0"),h=Date.UTC(o,s,l,m,c,d)-g,u=Math.floor(h/a),M=Math.floor(h/n-365*u),T=Math.floor((h-(365*u+M)*n)/t),f=Math.floor((h-(365*u+M)*n-T*t)/e),y=Math.floor((h-(365*u+M)*n-T*t-f*e)/1e3);if(r===String(o)){document.getElementById("year").innerHTML=o;var v="This site has been running for "+M+" days";v="本站已运行 "+M+" 天",document.getElementById("sitetime").innerHTML=v}else{document.getElementById("year").innerHTML=r+" - "+o;var H="This site has been running for "+u+" years and "+M+" days "+T+" hours "+f+" mins "+y+" seconds";H="本站已苟且偷生 "+u+" 年 "+M+" 天 "+T+" 小时 "+f+" 分钟 "+y+" 秒",document.getElementById("sitetime").innerHTML=H}};calcSiteTime(),setInterval(calcSiteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/zyxelva" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:zyxelva@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1807401971" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1807401971" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a> <a href="https://www.zhihu.com/people/kezade" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kezade" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="../rss2.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach(function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach(function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))}),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach(function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")}),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}}),t+="</ul>",s.innerHTML=t)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/masonry/masonry.pkgd.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/js/matery.js"></script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/background/ribbon-dynamic.js" async></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/instantpage/instantpage.js" type="module"></script></body></html>