<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="【Netty学习】3.Netty的组件, Back-End Dev Java"><meta name="description" content="1 为什么要用 Netty?
提供了 JAVA NIO但没有提供针对 Protocol Buffer、JSON 这些信息格式的封装。
NIO类库和 API 复杂，网络编程复杂，难度较大。
提供上层特有服务，如数据格式封装，客户端权限、简单的"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>【Netty学习】3.Netty的组件 | Kezade</title><link rel="icon" type="image/jpeg" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg"><style>body{background-image:url(https://it-ark-dev.oss-cn-shenzhen.aliyuncs.com/464e9ac7a5a729ae67f91f7cf0cf6fe2.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:cover;background-position:center center}</style><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/animate/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.1/css/matery.css?v3"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/my.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/post.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/reward.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/jquery/jquery-3.6.0.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.3/js/function.js?v88"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/imgStatus.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/waterfall.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/lately.min.js"></script><script>var memos={host:"https://s.dusays.com/",limit:"10",creatorId:"49",username:"zyxelva",name:"Kezade",domId:"#memos",path:"api/v1/memo"},douban={api:"https://douban-api.edui.fun/"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="Kezade" type="application/rss+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img k-avatar" alt="LOGO"> <span class="logo-span">Kezade</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-newspaper" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:0.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-sitemap" style="zoom:0.6"></i> <span>系列</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/categories/%E7%AE%97%E6%B3%95"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>考研</span></a></li><li><a href="/categories/OSSD"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>高考</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-place-of-worship" style="zoom:0.6"></i> <span>我的</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:0.6"></i> <span>相册</span></a></li><li><a href="/bibi"><i class="fa-fw fa-solid fa-cloud-rain" style="margin-top:-20px;zoom:0.6"></i> <span>哔哔</span></a></li><li><a href="/todolist"><i class="fa-fw fa-solid fa-circle-check" style="margin-top:-20px;zoom:0.6"></i> <span>清单</span></a></li><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:0.6"></i> <span>音乐</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-circle-info" style="zoom:0.6"></i> <span>更多</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:0.6"></i> <span>留言</span></a></li><li><a href="/friends"><i class="fa-solid fa-link" style="margin-top:-20px;zoom:0.6"></i> <span>友链</span></a></li><li><a href="/friend-circle"><i class="fa-solid fa-rss" style="margin-top:-20px;zoom:0.6"></i> <span>圈圈</span></a></li><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:0.6"></i> <span>关于</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img circle responsive-img"><div class="logo-name">Kezade</div><div class="logo-desc">7 年 Java 开发经验，其中 3 年以上大型系统架构设计经验，以及 2 年以上的团队管理经验 | 具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验 | 对 Zookeeper、Netty、Dubbo、Spring Cloud、 Spring 等开源框架源码有过深入研究，并且有一定的框架定制开发经验</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-newspaper"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-sitemap"></i> 系列<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/categories/%E7%AE%97%E6%B3%95" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>考研</span></a></li><li><a href="/categories/OSSD" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>高考</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-place-of-worship"></i> 我的<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/bibi" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-cloud-rain" style="position:absolute;left:50px"></i> <span>哔哔</span></a></li><li><a href="/todolist" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-circle-check" style="position:absolute;left:50px"></i> <span>清单</span></a></li><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-circle-info"></i> 更多<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="/friends" style="margin-left:75px"><i class="fa fa-solid fa-link" style="position:absolute;left:50px"></i> <span>友链</span></a></li><li><a href="/friend-circle" style="margin-left:75px"><i class="fa fa-solid fa-rss" style="position:absolute;left:50px"></i> <span>圈圈</span></a></li><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/cryptojs/crypto-js.min.js"></script><script></script><style>:root{--post-bg-image:url('https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/Netty.png')}</style><div class="bg-cover pd-header post-cover"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">【Netty学习】3.Netty的组件</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Netty/"><span class="chip bg-color">Netty</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Netty%E5%AD%A6%E4%B9%A0/" class="post-category">Netty学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-05-19</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 7.7k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 28 分</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h1 id="1-为什么要用-Netty"><a href="#1-为什么要用-Netty" class="headerlink" title="1 为什么要用 Netty?"></a>1 为什么要用 Netty?</h1><ul><li>提供了 <code>JAVA NIO</code>但<code>没有提供</code>针对 <code>Protocol Buffer</code>、<code>JSON</code> 这些信息格式的<code>封装</code>。</li><li>NIO类库和 API <code>复杂</code>，<code>网络编程复杂</code>，<code>难度较大</code>。</li><li>提供上层特有服务，如数据格式封装，客户端权限、简单的数据读取、断连重连、半包读写、心跳等。</li><li><p><code>JAVA NIO</code> 存在 <code>epoll bug</code>, <code>selector</code> 不能阻塞，CPU 会飚至 100%（只能在 LINUX 内核上重现），Netty 已经解决。</p><ul><li><p>原因：</p><blockquote><p>因为<code>poll</code>和<code>epoll</code>对于<strong>突然中断</strong>的连接socket会对返回的<code>eventSet事件集合</code>置为<code>POLLHUP</code>或者<code>POLLERR</code>，<code>eventSet事件集合</code>发生了变化，这就导致<code>Selector</code>会<strong>被唤醒</strong>，进而导致CPU 100%问题。<code>根本原因</code>就是<strong>JDK没有处理好这种情况</strong>。</p></blockquote></li><li><p>netty 解决办法：</p><blockquote><p>创建一个新的<code>Selector</code>。处理机制就是如果发生了这种情况，并且发生次数超过了<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>(默认512)，则调用<code>rebuildSelector()</code>进行<code>Selecttor重建</code>，这样就不用管之前发生了异常情况的那个连接了。因为重建也是根据<code>SelectionKey事件</code>对应的<code>连接</code>来<code>重新注册</code>的。</p></blockquote></li><li>NIO <code>epoll bug</code>不是<code>linux epoll</code>的问题，而是<code>JDK</code>自己实现<code>epoll</code>时没有考虑这种情况。</li></ul></li></ul><h1 id="2-为什么Netty-使用NIO而不是AIO？"><a href="#2-为什么Netty-使用NIO而不是AIO？" class="headerlink" title="2 为什么Netty 使用NIO而不是AIO？"></a>2 为什么Netty 使用NIO而不是AIO？</h1><ul><li>Netty 不看重<code>Windows</code>上的使用，在<code>Linux</code>系统上，AIO 的底层实现仍使用<code>EPOLL</code>，没有很好实现<code>AIO</code>，因此在性能上没有明显的优势，而且被<code>JDK</code> 封装了一层不容易深度优化。</li><li>AIO 还有个<code>缺点</code>是接收数据需要<code>预先分配缓存</code>, 而不是NIO 那种<code>需要接收</code>时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多。</li></ul><h1 id="3-为什么不用Netty5"><a href="#3-为什么不用Netty5" class="headerlink" title="3 为什么不用Netty5?"></a>3 为什么不用Netty5?</h1><p>Netty5 已经停止开发。</p><h1 id="4-Netty-组件"><a href="#4-Netty-组件" class="headerlink" title="4 Netty 组件"></a>4 Netty 组件</h1><h2 id="4-1-Channel"><a href="#4-1-Channel" class="headerlink" title="4.1 Channel"></a>4.1 Channel</h2><p>代表一个到<code>实体</code>（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O 操作的程序组件）的<code>开放连接</code>，如<code>读操作</code>和<code>写操作</code>。</p><p>目前，可以把Channel看作是<code>传入</code>（入站）或者<code>传出</code>（出站）数据的载体。因此，它可以<code>被打开</code>或者<code>被关闭</code>，<code>连接</code>或者<code>断开连接</code>。</p><p><img src="/images/uploads/abstract-channel.png" alt="抽象的Channel"></p><ul><li><p>生命周期</p><ul><li>ChannelUnregistered：<code>Channel</code> 已经<code>被创建</code>，但还<code>未注册</code>到<code>EventLoop</code>；</li><li>ChannelRegistered：<code>Channel</code> 已经<code>被注册</code>到了<code>EventLoop</code>；</li><li>ChannelActive：<code>Channel</code>处于<code>活动状态</code>（已经连接到它的远程节点）。它现在可以<code>接收</code>和<code>发送</code>数据了；</li><li>ChannelInactive：<code>Channel</code> 没有连接到远程节点，当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给<code>ChannelPipeline</code>中的<code>ChannelHandler</code>，其可以随后对它们做出响应。</li></ul></li></ul><p>当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给<code>ChannelPipeline</code>中的<code>ChannelHandler</code>，其可以随后对它们做出响应。</p><p><img src="/images/uploads/channel-life.png" alt="Channel生命周期"></p><ul><li>接口</li></ul><p>基本的 <code>I/O 操作</code>(<code>bind()</code>、<code>connect()</code>、<code>read()</code>和 <code>write()</code>)依赖于底层网络传输所提供的<code>原语</code>。在基于 Java 的网络编程中，其基本的构造是<code>类 Socket</code>。Netty 的 <code>Channel 接口</code>所提供的 <code>API</code>，被用于所有的 <code>I/O 操作</code>。大大地降低了直接使用 Socket 类的复杂性。此外，Channel 也是拥有许多<code>预定义的</code>、<code>专门化实现的</code>广泛类层次结构的根。</p><p>由于Channel 是<code>独一无二</code>的，所以为了保证顺序将Channel 声明为<code>java.lang.Comparable</code> 的一个<code>子接口</code>。因此，如果两个不同的 <code>Channel 实例</code>都返回了相同的散列码，那么 <code>AbstractChannel</code> 中的 <code>compareTo()方法</code>的实现将会抛出一个 <code>Error</code>。</p><ul><li>最重要 Channel 的方法<ul><li><code>eventLoop</code>: 返回分配给 Channel 的 EventLoop</li><li><code>pipeline</code>: 返回分配给 Channel 的 ChannelPipeline</li><li><code>isActive</code>: 如果 Channel 是活动的，则返回 true。活动的意义可能依赖于底层的传输。 例如，一个 Socket 传输一旦连接到了远程节点便是活动的，而一个 Datagram 传输一旦被 打开便是活动的。</li><li><code>localAddress</code>: 返回<strong>本地</strong>的 <code>SokcetAddress</code></li><li><code>remoteAddress</code>: 返回<strong>远程</strong>的 <code>SocketAddress</code></li><li><code>write</code>: 将数据写到远程节点。这个数据将被传递给 <code>ChannelPipeline</code>，并且排队直到它被冲刷</li><li><code>flush</code>: 将之前已写的数据冲刷到底层传输，如一个 <code>Socket</code><br>+<code>writeAndFlush</code>: 一个简便的方法，等同于调用 <code>write()</code>并接着调用 <code>flush()</code></li></ul></li></ul><h2 id="4-2-EventLoop-Group"><a href="#4-2-EventLoop-Group" class="headerlink" title="4.2 EventLoop(Group)"></a>4.2 EventLoop(Group)</h2><p>回想一下我们在 <code>NIO</code> 中是如何处理我们关心的事件的?</p><blockquote><p>在一个 <code>while</code> 循环中 <code>select</code> 出事件，然后依次处理每种事件。我们可以把它称为<code>事件循环</code>，这就是 <code>EventLoop</code>。</p></blockquote><p><code>interface io.netty.channel.EventLoop</code> 定义了 Netty 的核心抽象，用于处理网络连接的生命周期中所发生的事件。</p><p>Netty 的 <code>EventLoop</code> 是<code>协同设计</code> 的一部分，它采用了两个基本的 API:<code>并发</code>和<code>网络编程</code>。</p><ul><li><code>io.netty.util.concurrent</code> 包构建在 JDK 的 <code>java.util.concurrent</code> 包上，用来提供<code>线程执行器</code>。</li><li><code>io.netty.channel</code> 包中的类，为了与 <code>Channel</code> 的事件进行交互， 扩展了这些接口/类。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/EventLoop.png"><div class="caption"><b class="center-caption">EventLoop类层次结构</b></div></li><li>一个 <code>EventLoop</code> 将由一个<strong>永远都不会改变</strong>的 <code>Thread</code> 驱动，同时<code>任务</code>(Runnable 或者 Callable)可以<strong>直接</strong>提交给 <code>EventLoop</code> 实现，以立即执行或者调度执行。</li><li>Netty 的 <code>EventLoop</code> 在继承了 <code>ScheduledExecutorService</code> 的同时，只定义了一个方法， <code>parent()</code>。在 <code>Netty 4</code> 中，所有的 <code>I/O 操作和事件</code>都由已经被分配给了 <code>EventLoop</code> 的那个 <code>Thread</code> 来处理。</li></ul><p><code>EventLoopGroup</code> 是一组 <code>EventLoop</code>，Channel 一般会调用 <code>EventLoopGroup</code> 的 <code>register</code> 方法来<code>绑定</code>其中一个 <code>EventLoop</code>，后续这个 Channel 上的 <code>IO 事件</code>都由此 <code>EventLoop</code> 来处理（保证了 IO 事件处理时的线程安全）。</p><h3 id="4-2-1-任务调度"><a href="#4-2-1-任务调度" class="headerlink" title="4.2.1 任务调度"></a>4.2.1 任务调度</h3><p>偶尔，你将需要调度一个任务以便稍后(延迟)执行或者周期性地执行。例如，你可能想要注册一个在客户端已经连接了 5 分钟之后触发的任务。一个常见的用例是，发送<code>心跳消息</code>到远程节点，以检查连接是否仍然还活着。如果没有响应，你便知道可以关闭该 <code>Channel</code> 了。</p><h3 id="4-2-2-线程管理"><a href="#4-2-2-线程管理" class="headerlink" title="4.2.2 线程管理"></a>4.2.2 线程管理</h3><p>在内部，当提交任务到如果(当前)调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被(直接)执行。否则，EventLoop 将调度该任务以便稍后执行，并将它放入 到内部队列中。当 EventLoop 下次处理它的事件时，它会执行队列中的那些任务/事件。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/EventLoop%20Execution%20Logic.png"></p><div class="caption"><b class="center-caption">EventLoop的执行逻辑</b></div><p></p><h3 id="4-2-3-线程分配"><a href="#4-2-3-线程分配" class="headerlink" title="4.2.3 线程分配"></a>4.2.3 线程分配</h3><p>服务于 Channel 的 <code>I/O</code> 和事件的 <code>EventLoop</code> 包含在 <code>EventLoopGroup</code> 中。根据不同的传输实现，<code>EventLoop</code> 的创建和分配方式也不同。</p><ul><li>异步传输</li></ul><p>异步传输实现只使用了<code>少量的 EventLoop</code>(以及和它们相关联的 <code>Thread</code>)，而且在当前的线程模型中，它们可能会被多个 <code>Channel</code> 所共享。这使得可以通过尽可能少量的 <code>Thread</code> 来支撑大量的 <code>Channel</code>，而不是每个 <code>Channel</code> 分配一个 <code>Thread</code>。<br>下图中显示了一个 <code>EventLoopGroup</code>，它具有 3 个<code>固定大小</code>的 <code>EventLoop</code>(每个 EventLoop 都由一个 Thread 支撑)。在创建 <code>EventLoopGroup</code> 时就直接分配了 <code>EventLoop</code>(以及支撑它们的 <code>Thread</code>)，以确保在需要时它们是可用的。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/NIO%20Dispatch%20Model.png"><div class="caption"><b class="center-caption">用于非阻塞传输(如 NIO 和 AIO)的 EventLoop 分配方式</b></div><ul><li>阻塞传输</li></ul><p>用于像 <code>OIO</code>(旧的阻塞 I/O)这样的其他传输的设计略有不同，如下图所示。这里每一个 <code>Channel</code> 都将被分配给<code>一个 EventLoop</code>(以及它的 Thread)。如果你开发的应用程序使用过 <code>java.io</code> 包中的<code>阻塞 I/O</code> 实现，你可能就遇到过这种模型。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/OIO%20Dispatch%20Model.png"></p><div class="caption"><b class="center-caption">阻塞传输(如 OIO)的 EventLoop 分配方式</b></div><p></p><p>但是，正如同之前一样，得到的保证是每个 <code>Channel</code> 的 <code>I/O 事件</code>都将只会被<code>一个 Thread</code> (用于支撑该 Channel 的 EventLoop 的那个 Thread)处理。这也是另一个 Netty <code>设计一致性</code>的例子，它(这种设计上的一致性)对 Netty 的<code>可靠性</code>和<code>易用性</code>做出了巨大贡献。</p><h2 id="4-3-ChannelFuture"><a href="#4-3-ChannelFuture" class="headerlink" title="4.3 ChannelFuture"></a>4.3 ChannelFuture</h2><blockquote><p>Netty 中所有的 I/O 操作都是<code>异步的</code>。</p></blockquote><p>JDK 预置了 <code>interface java.util.concurrent.Future</code>，<code>Future</code> 提供了一种在操作完成时<code>通知</code>应用程序的方式。这个对象可以看作是一个<code>异步操作</code>的结果的<code>占位符</code>;</p><ul><li>它将在未来的某个时刻完成，并提供对其结果的访问。但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty 提供了它自己的实现—— <code>ChannelFuture</code>，用于在执行<code>异步操作</code>的时候使用。</li><li>每个 Netty 的<code>出站</code> I/O 操作都将返回一个 <code>ChannelFuture</code>。也就是说，它们都不会阻塞。 正如我们前面所提到过的一样，Netty 完全是<code>异步</code>和<code>事件驱动</code>的。</li></ul><h2 id="4-4-ChannelHandler"><a href="#4-4-ChannelHandler" class="headerlink" title="4.4 ChannelHandler"></a>4.4 ChannelHandler</h2><p>从应用程序开发人员的角度来看，Netty 的主要组件是 <code>ChannelHandler</code>，它充当了所有处理<code>入站</code>和<code>出站</code>数据的应用程序逻辑的<code>容器</code>。</p><p><code>ChannelHandler</code> 的方法是由<code>网络事件</code>触发的。 事实上，<code>ChannelHandler</code> 可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另外一种格式，例如各种编解码，或者处理转换过程中所抛出的异常。</p><ul><li>ChannelHandler 的生命周期：在<code>ChannelHandler</code>被<code>添加</code>到<code>ChannelPipeline</code> 中或者被从<code>ChannelPipeline</code> 中<code>移除</code>时会调用下面这些方法。这些方法中的每一个都接受一个 <code>ChannelHandlerContext</code> 参数。<ul><li><code>handlerAdded</code>：当把 <code>ChannelHandler</code> <code>添加</code>到 <code>ChannelPipeline</code> 中时被调用；</li><li><code>handlerRemoved</code>：当从 <code>ChannelPipeline</code> 中<code>移除</code> <code>ChannelHandler</code> 时被调用；</li><li><code>exceptionCaught</code>：当处理过程中在 <code>ChannelPipeline</code> 中<code>有错误产生</code>时被调用。</li></ul></li></ul><p>Netty 定义了下面两个重要的 <code>ChannelHandler</code> 子接口:</p><ul><li><code>ChannelInboundHandler</code>: 处理<code>入站</code>数据以及各种<code>状态</code>变化;</li><li><code>ChannelOutboundHandler</code>: 处理<code>出站</code>数据并且允许<code>拦截</code>所有的操作。</li></ul><p>另外，3 个 <code>ChannelHandler</code> 的子类型：<code>编码器</code>、<code>解码器</code>和 <code>SimpleChannelInboundHandler&lt;T&gt;</code> —— <code>ChannelInboundHandlerAdapter</code> 的一个<code>子类</code>。</p><h3 id="4-4-1-ChannelInboundHandler-接口"><a href="#4-4-1-ChannelInboundHandler-接口" class="headerlink" title="4.4.1 ChannelInboundHandler 接口"></a>4.4.1 ChannelInboundHandler 接口</h3><p>下面列出了接口 <code>ChannelInboundHandler</code> 的生命周期方法。这些方法将会在数据<code>被接收</code>时或者与其对应的 Channel <code>状态发生改变</code>时被调用。正如我们前面所提到的，这些方法和 Channel 的生命周期<code>密切相关</code>。</p><ul><li><code>channelRegistered</code>：当 <code>Channel</code> 已经<code>注册</code>到它的 <code>EventLoop</code> 并且能够处理 <code>I/O</code> 时被调用；</li><li><code>channelUnregistered</code>：当 <code>Channel</code> 从它的 <code>EventLoop</code> <code>注销</code>并且无法处理任何 <code>I/O</code> 时被调用；</li><li><code>channelActive</code>：当 <code>Channel</code> 处于<code>活动状态</code>时被调用；<code>Channel</code> 已经<code>连接/绑定</code>并且已经<code>就绪</code>；</li><li><code>channelInactive</code>：当<code>Channel</code><strong>离开</strong>活动状态并且<code>不再连接</code>它的远程节点时被调用；</li><li><code>channelReadComplete</code>：当 <code>Channel</code> 上的一个<code>读操作``完成</code>时被调用；</li><li><code>channelRead</code>：当从 <code>Channel</code> <code>读取数据</code>时被调用；</li><li><code>ChannelWritabilityChanged</code>：当 <code>Channel</code> 的<code>可写状态</code>发生改变时被调用。可以通过调用 <code>Channel</code> 的 <code>isWritable()</code>方法来检测 <code>Channel</code> 的<code>可写性</code>。<blockquote><p>与可写性相关的阈值可以通过<code>Channel.config().setWriteHighWaterMark()</code>和<code>Channel.config().setWriteLowWaterMark()</code>方法来设置；</p></blockquote></li><li><code>userEventTriggered</code>：当 <code>ChannelInboundHandler.fireUserEventTriggered()</code>方法被调用时被调用。</li></ul><h3 id="4-4-2-ChannelOutboundHandler-接口"><a href="#4-4-2-ChannelOutboundHandler-接口" class="headerlink" title="4.4.2 ChannelOutboundHandler 接口"></a>4.4.2 ChannelOutboundHandler 接口</h3><p><code>出站操作</code>和数据将由 <code>ChannelOutboundHandler</code> 处理。它的方法将被 <code>Channel</code>、<code>ChannelPipeline</code> 以及 <code>ChannelHandlerContext</code> 调用。</p><p>所有由 ChannelOutboundHandler 本身所定义的方法:</p><ul><li>bind(ChannelHandlerContext,SocketAddress,ChannelPromise)：当请求将 <code>Channel</code> <code>绑定</code>到本地地址时被调用；</li><li>connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)：当请求将 <code>Channel</code> <code>连接</code>到远程节点时被调用；</li><li>disconnect(ChannelHandlerContext,ChannelPromise)：当请求将 <code>Channel</code> 从远程节点<code>断开</code>时被调用</li><li>close(ChannelHandlerContext,ChannelPromise)：当请求<code>关闭 Channel</code> 时被调用；</li><li>deregister(ChannelHandlerContext,ChannelPromise)：当请求将 <code>Channel</code> 从它的 <code>EventLoop</code> <code>注销</code>时被调用；</li><li>read(ChannelHandlerContext)：当请求从 <code>Channel</code> <code>读取</code>更多的数据时被调用；</li><li>flush(ChannelHandlerContext)：当请求通过 <code>Channel</code> 将<code>入队数据``冲刷</code>到<code>远程节点</code>时被调用；</li><li>write(ChannelHandlerContext,Object,ChannelPromise)：当请求通过 <code>Channel</code> 将数据<code>写</code>到远程节点时被调用；</li></ul><h3 id="4-4-3-ChannelInboundHandlerAdapter"><a href="#4-4-3-ChannelInboundHandlerAdapter" class="headerlink" title="4.4.3 ChannelInboundHandlerAdapter"></a>4.4.3 ChannelInboundHandlerAdapter</h3><p>有一些适配器类可以将编写自定义的 <code>ChannelHandler</code> 所需要的工作降到<code>最低限度</code>，因为它们提供了定义在对应接口中的所有方法的<code>默认实现</code>。因为你有时会忽略那些不感兴趣的事件，所以 Netty 提供了抽象基类 <code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code>。</p><blockquote><p>下面这些是编写自定义 ChannelHandler 时经常会用到的适配器类:</p><ul><li>ChannelHandlerAdapter</li><li>ChannelInboundHandlerAdapter</li><li>ChannelOutboundHandlerAdapter</li><li>ChannelDuplexHandler</li></ul></blockquote><h3 id="4-4-4-编码器和解码器"><a href="#4-4-4-编码器和解码器" class="headerlink" title="4.4.4 编码器和解码器"></a>4.4.4 编码器和解码器</h3><p>网络数据总是一些字节，需要通过解码解析给系统，让其能够认识；同样从系统写出去的数据，具有普遍认可度的一般是二进制，所以需要进行编码；</p><p>对应于特定的需要，Netty 为<code>编码器</code>和<code>解码器</code>提供了不同类型的<code>抽象类</code>。通常来说，这些基类的名称将类似于 <code>ByteToMessageDecoder</code> 或 <code>MessageToByteEncoder</code>。对于特殊的类型，你可能会发现类似于 <code>ProtobufEncoder</code> 和 <code>ProtobufDecoder</code> 这样的名称——预置的用来支持 Google 的 <code>Protocol Buffers</code>。</p><p>所有由 Netty 提供的<code>编码器/解码器适配器类</code>都实现 了 <code>ChannelOutboundHandler</code> 或者 <code>ChannelInboundHandler</code> 接口。</p><h3 id="4-4-5-抽象类-SimpleChannelInboundHandler"><a href="#4-4-5-抽象类-SimpleChannelInboundHandler" class="headerlink" title="4.4.5 抽象类 SimpleChannelInboundHandler"></a>4.4.5 抽象类 SimpleChannelInboundHandler</h3><p>最常见的情况是，你的应用程序会利用一个 <code>ChannelHandler</code> 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，你只需要扩展基类 <code>SimpleChannelInboundHandler&lt;T&gt;</code>，其中 <code>T</code> 是你要处理的消息的 <code>Java 类型</code> 。在这个 ChannelHandler 中， 你将需要<code>重写</code>基类的一个或者多个方法，并且获取一个到 <code>ChannelHandlerContext</code> 的<code>引用</code>， 这个引用将作为输入参数传递给 ChannelHandler 的所有方法。</p><p>在这种类型的 <code>ChannelHandler</code> 中，最重要的方法是 <code>channelRead0(ChannelHandlerContext, T)</code>。除了要求<code>不要阻塞</code>当前的 <code>I/O 线程</code>之外，其具体实现完全取决于你。后续再讲编解码器时，我将对这一主题进行更多的说明。</p><h2 id="4-5-ChannelPipeline"><a href="#4-5-ChannelPipeline" class="headerlink" title="4.5 ChannelPipeline"></a>4.5 ChannelPipeline</h2><p>当 <code>Channel</code> 被<code>创建</code>时，它将会被<code>自动地分配</code>一个新的 <code>ChannelPipeline</code>。这项关联是<code>永久性的</code>。</p><p><code>Channel</code> 既<code>不能附加</code>另外一个 <code>ChannelPipeline</code>，也<code>不能分离</code>其当前的。在 Netty 组件的生命周期中，这是一项<code>固定的</code>操作，不需要开发人员的任何干预。</p><p>使得事件流经 <code>ChannelPipeline</code> 是 <code>ChannelHandler</code> 的工作，它们是在应用程序的<code>初始化</code>或者<code>引导阶段</code>被安装的。这些对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个 <code>ChannelHandler</code>。它们的执行顺序是由它们<code>被添加的顺序</code>所决定的。</p><h3 id="4-5-1-ChannelPipeline-中-ChannelHandler"><a href="#4-5-1-ChannelPipeline-中-ChannelHandler" class="headerlink" title="4.5.1 ChannelPipeline 中 ChannelHandler"></a>4.5.1 ChannelPipeline 中 ChannelHandler</h3><p><code>入站</code>和<code>出站</code> <code>ChannelHandler</code> 可以被安装到同一个 <code>ChannelPipeline</code> 中。如果一个消息或者任何其他的入站事件被读取，那么它会从 ChannelPipeline 的<code>头部</code>开始流动，最终，数据将会到达 <code>ChannelPipeline</code> 的<code>尾端</code>，届时，所有处理就都结束了。</p><p>数据的<code>出站运动</code>(即正在被写的数据)在概念上也是一样的。在这种情况下，数据将从 <code>ChannelOutboundHandler</code> 链的<code>尾端</code>开始流动，直到它到达链的<code>头部</code>为止。在这之后，出站数据将会到达<code>网络传输层</code>，这里显示为 Socket。通常情况下，这将触发一个<code>写操作</code>。</p><p>如果将两个类别的<code>ChannelHandler</code>都混合添加到同一个<code>ChannelPipeline</code> 中会发生什么。 虽然 <code>ChannelInboundHandle</code> 和 <code>ChannelOutboundHandle</code> 都扩展自 <code>ChannelHandler</code>，但是 Netty 能区分 <code>ChannelInboundHandler</code> 实现和 <code>ChannelOutboundHandler</code> 实现，并确保数据只会在具有<code>相同定向类型</code>的两个 <code>ChannelHandler</code> 之间传递。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ChannelPipeline.png"><div class="caption"><b class="center-caption">包含入站出站的pipeline</b></div><h2 id="4-6-ChannelHandlerContext"><a href="#4-6-ChannelHandlerContext" class="headerlink" title="4.6 ChannelHandlerContext"></a>4.6 ChannelHandlerContext</h2><p>通过使用作为参数传递到每个方法的 <code>ChannelHandlerContext</code>，事件可以被传递给当前 <code>ChannelHandler</code> 链中的<code>下一个 ChannelHandler</code>。虽然这个对象可以被用于获取底层的 Channel，但是它主要还是被用于<code>写出站数据</code>。</p><p><code>ChannelHandlerContext</code> 代表了<code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> <code>添加</code>到 <code>ChannelPipeline</code> 中时，都会创建 <code>ChannelHandlerContext</code>。</p><p><code>ChannelHandlerContext</code> 的主要功能是管理它所关联的 <code>ChannelHandler</code> 和在同一个 <code>ChannelPipeline</code> 中的其他 <code>ChannelHandler</code> 之间的交互。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ChannelHandler-in-ChannelHandlerContext.png"><div class="caption"><b class="center-caption">ChannelHandler与ChannelHandlerContext</b></div><p><code>ChannelHandlerContext</code> 有很多的方法，其中一些方法也存在于 <code>Channel</code> 和 <code>ChannelPipeline</code> 本身上，但是有一点重要不同。如果调用<code>Channel</code> 或者<code>ChannelPipeline</code> 上的这些方法，它们将沿着<code>整个 ChannelPipeline</code>进行传播。而调用位于 <code>ChannelHandlerContext</code>上的相同方法，则将从<code>当前所关联的 ChannelHandler</code> 开始，并且<code>只会</code>传播给位于该 <code>ChannelPipeline</code> 中的<code>下一个</code>(入站下一个，出站上一个)能够处理该事件的 <code>ChannelHandler</code>。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ChannelPipeline2.png"><div class="caption"><b class="center-caption">ChannelPipeline、ChannelHandler与ChannelHandlerContext</b></div><h3 id="4-6-1-ChannelHandlerContext-的-API"><a href="#4-6-1-ChannelHandlerContext-的-API" class="headerlink" title="4.6.1 ChannelHandlerContext 的 API"></a>4.6.1 ChannelHandlerContext 的 API</h3><ul><li><code>alloc</code> 返回和这个实例相关联的 <code>Channel</code> 所配置的 <code>ByteBufAllocator</code></li><li><code>bind</code> 绑定到给定的 <code>SocketAddress</code>，并返回 <code>ChannelFuture</code></li><li><code>channel</code> 返回绑定到这个实例的 <code>Channel</code></li><li><code>close</code> 关闭 <code>Channel</code>，并返回 <code>ChannelFuture</code></li><li><code>connect</code> 连接给定的 <code>SocketAddress</code>，并返回 <code>ChannelFuture</code></li><li><code>deregister</code> 从之前分配的 <code>EventExecutor</code> 注销，并返回 <code>ChannelFuture</code></li><li><code>disconnect</code> 从远程节点断开，并返回 <code>ChannelFuture</code></li><li><code>executor</code> 返回调度事件的 <code>EventExecutor</code></li><li><code>fireChannelActive</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>channelActive()</code>方法(已连接)的调用</li><li><code>fireChannelInactive</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>channelInactive()</code>方法 (已关闭)的调用</li><li><code>fireChannelRead</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>channelRead()</code>方法(已接收的消息)的调用</li><li><code>fireChannelReadComplete</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>channelReadComplete()</code>方法的调用</li><li><code>fireChannelRegistered</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>fireChannelRegistered()</code>方法的调用</li><li><code>fireChannelUnregistered</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>fireChannelUnregistered()</code>方法的调用</li><li><code>fireChannelWritabilityChanged</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>fireChannelWritabilityChanged()</code>方法的调用</li><li><code>fireExceptionCaught</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>fireExceptionCaught(Throwable)</code>方法的调用</li><li><code>fireUserEventTriggered</code> 触发对下一个 <code>ChannelInboundHandler</code> 上的 <code>fireUserEventTriggered(Object evt)</code>方法的调用</li><li><code>handler</code> 返回绑定到这个实例的 <code>ChannelHandler</code></li><li><code>isRemoved</code> 如果所关联的 <code>ChannelHandler</code> 已经被从 <code>ChannelPipeline</code> 中<code>移除</code>则返回 true</li><li><code>name</code> 返回这个实例的<code>唯一</code>名称</li><li><code>pipeline</code> 返回这个实例所关联的 <code>ChannelPipeline</code></li><li><code>read</code> 将数据从 <code>Channel</code> 读取到第一个入站缓冲区;如果读取成功则触发一个 <code>channelRead</code> 事件，并(在最后一个消息被读取完成后)通知 <code>ChannelInboundHandler</code> 的 <code>channelReadComplete(ctx)</code>方法</li><li><code>write</code> 通过这个实例<code>写入</code>消息并<code>经过</code> <code>ChannelPipeline</code></li><li><code>writeAndFlush</code> 通过这个实例<code>写入并冲刷</code>消息并<code>经过</code> <code>ChannelPipeline</code></li></ul><blockquote><p>当使用 <code>ChannelHandlerContext</code> 的 <code>API</code> 的时候，有以下<strong>两点</strong>:</p><ul><li><code>ChannelHandlerContext</code> 和 <code>ChannelHandler</code> 之间的<code>关联(绑定)</code>是<code>永远不会改变的</code>， 所以缓存对它的引用是<code>安全的</code>;</li><li>如同我们在本节开头所解释的一样，相对于其他类的同名方法，<code>ChannelHandlerContext</code> 的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</li></ul></blockquote><h2 id="4-7-内置通讯传输模式"><a href="#4-7-内置通讯传输模式" class="headerlink" title="4.7 内置通讯传输模式"></a>4.7 内置通讯传输模式</h2><ul><li><code>NIO</code>: <code>io.netty.channel.socket.nio</code>使用 <code>java.nio.channels</code> 包作为基础——基于<code>选择器</code>的方式；</li><li><code>Epoll</code>：<code>io.netty.channel.epoll</code> 由 <code>JNI</code> 驱动的 <code>epoll()</code>和<code>非阻塞 IO</code>。这个传输支持只有在 <code>Linux</code> 上可用的多种特性，如 <code>SO_REUSEPORT</code>，比 <code>NIO</code> 传输更快，而且是完全<code>非阻塞</code>的。将 <code>NioEventLoopGroup</code> 替换为 <code>EpollEventLoopGroup</code> ， 并且将 <code>NioServerSocketChannel.class</code> 替换为 <code>EpollServerSocketChannel.class</code> 即可；</li><li><code>OIO</code>：<code>io.netty.channel.socket.oio</code> 使用 <code>java.net</code> 包作为基础——使用<code>阻塞流</code>；</li><li><code>Local</code>：<code>io.netty.channel.local</code> 可以在 <code>VM</code> 内部通过<code>管道</code>进行通信的<code>本地</code>传输</li><li><code>Embedded</code>：<code>io.netty.channel.embedded</code>，允许使用 <code>ChannelHandler</code> 而又不需要一个真正的基于网络的传输。在测试 <code>ChannelHandler</code> 实现时非常有用。</li></ul><h2 id="4-8-Bootstrap"><a href="#4-8-Bootstrap" class="headerlink" title="4.8 Bootstrap"></a>4.8 Bootstrap</h2><p>网络编程里，<code>服务器</code>和<code>客户端</code>实际上表示了<code>不同的网络行为</code>。换句话说，是<code>监听</code>传入的连接还是<code>建立</code>到一个或者多个进程的连接。<br>因此，有两种类型的引导：</p><ul><li>一种用于<code>客户端</code>(简单地称为 <code>Bootstrap</code>)；</li><li>另一种用于<code>服务器</code> (<code>ServerBootstrap</code>)。</li></ul><p>无论你的应用程序使用哪种协议或者处理哪种类型的数据， <code>唯一</code>决定它使用哪种引导类的是：<strong>它是作为一个客户端还是作为一个服务器</strong>。</p><p>比较 <code>Bootstrap</code> 类：</p><div class="table-container"><table><thead><tr><th>Differents</th><th>Bootstrap</th><th>ServerBootstrap</th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td><code>EventLoopGroup</code> 的数目</td><td>1</td><td>2</td></tr></tbody></table></div><blockquote><p>为啥<code>ServerBootstrap</code>需要两个<code>EventLoopGroup</code>?<br>因为服务器需要<code>两组不同的 Channel</code>：</p><ul><li>第一组将只包含<code>一个 ServerChannel</code>，代表服务器自身的<code>已绑定</code>到某个<code>本地端口</code>的正在<code>监听</code>的套接字。</li><li>而第二组将包含所有已创建的用来处理传入<code>客户端连接</code>(对于每个服务器已经接受的连接都有一个)的 <code>Channel</code>。</li></ul><p>实际上，<code>ServerBootstrap类</code>也可以只使用<code>一个EventLoopGroup</code>，此时其将在两个场景下共用<code>同一个EventLoopGroup</code>。</p></blockquote><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Two-EventLoopGroups-of-a-Server.png"><div class="caption"><b class="center-caption">具有两个 EventLoopGroup 的服务器</b></div><h2 id="4-9-ByteBuf"><a href="#4-9-ByteBuf" class="headerlink" title="4.9 ByteBuf"></a>4.9 ByteBuf</h2><p>网络中的数据，其基本单位是字节，在<code>JAVA NIO</code>中，利用<code>ByteBuffer</code>作为字节的数据载体，但是之所以有Netty，不就是因为原生网络编程复杂，且API较晦涩咩？因而Netty提供了另外的载体—-<code>ByteBuf</code>，一个强大的实现，既解决了 <code>JDK API</code> 的局限性， 又为网络应用程序的开发者提供了更好的 API。</p><h3 id="4-9-1-工作原理"><a href="#4-9-1-工作原理" class="headerlink" title="4.9.1 工作原理"></a>4.9.1 工作原理</h3><p><code>ByteBuf</code> 维护了<strong>两个不同的索引</strong>：</p><ul><li>一个用于<code>读取</code></li><li>一个用于<code>写入</code>。</li></ul><p>当你从 <code>ByteBuf</code> <code>读取</code>时， 它的 <code>readerIndex</code> 将会<code>被递增</code>已经被读取的字节数。同样地，当你<code>写入 ByteBuf</code>时，它的 <code>writerIndex</code> 也会<code>被递增</code>。下图展示了一个<code>空 ByteBuf</code> 的布局结构和状态。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/A-Blank-ByteBuf.png"></p><div class="caption"><b class="center-caption">一个读索引和写索引都设置为 0 的 16 字节 ByteBuf</b></div><p></p><p>要了解这些索引<code>两两之间</code>的关系，请考虑一下，如果打算<code>读取</code>字节直到 <code>readerIndex</code> 达到和 <code>writerIndex</code> 同样的值时会发生什么。在那时，你将会到达<code>可以读取的</code>数据的末尾。就如同试图读取<code>超出</code>数组末尾的数据一样，试图读取超出该点的数据将会触发一个 <code>IndexOutOfBoundsException</code>。</p><p>名称以 <code>read</code> 或者 <code>write</code> 开头的 <code>ByteBuf</code> 方法，将会推进其对应的索引，而名称以 <code>set</code> 或 者 <code>get</code> 开头的操作则不会。后面的这些方法将在作为一个<code>参数</code>传入的一个<code>相对索引</code>上执行操作。</p><p>可以指定 <code>ByteBuf</code> 的<strong>最大容量</strong>。试图移动<code>写索引</code>(即 <code>writerIndex</code>)超过这个值将会触发一个<code>异常</code>。(默认的限制是 <code>Integer.MAX_VALUE</code>。)</p><h3 id="4-9-1-ByteBuf-API-的优点"><a href="#4-9-1-ByteBuf-API-的优点" class="headerlink" title="4.9.1 ByteBuf API 的优点"></a>4.9.1 ByteBuf API 的优点</h3><ul><li>它可以被用户自定义的缓冲区类型<code>扩展</code>;</li><li>通过内置的<code>复合缓冲区</code>类型实现了透明的<code>零拷贝</code>;</li><li><code>容量</code>可以<code>按需增长</code>(类似于 JDK 的 <code>StringBuilder</code>);</li><li>在<code>读</code>和<code>写</code>这两种模式之间切换<strong>不需要</strong>调用 <code>ByteBuffer</code> 的 <code>flip()</code>方法;</li><li><code>读</code>和<code>写</code>使用了<strong>不同的索引</strong>;</li><li>支持方法的<code>链式调用</code>;</li><li>支持<code>引用计数</code>;</li><li>支持<code>池化</code>.</li></ul><h3 id="4-9-2-使用模式"><a href="#4-9-2-使用模式" class="headerlink" title="4.9.2 使用模式"></a>4.9.2 使用模式</h3><ul><li>堆缓冲区</li></ul><p>最常用的 <code>ByteBuf模式</code>是将数据存储在 JVM 的<code>堆空间</code>中。这种模式被称为<code>支撑数组</code> (backing array)，它能在没有使用<code>池化</code>的情况下提供快速的<code>分配和释放</code>。可以由 <code>hasArray()</code> 来判断检查 ByteBuf 是否由<code>数组</code>支撑。如果不是，则这是一个<code>直接缓冲区</code>。</p><ul><li>直接缓冲区</li></ul><p><code>直接缓冲区</code>是另外一种 ByteBuf 模式。直接缓冲区的<strong>主要缺点</strong>是，相对于基于堆的缓冲区，它们的分配和释放都较为<code>昂贵</code>。</p><p>-复合缓冲区</p><p><code>复合缓冲区CompositeByteBuf</code>，它为<strong>多个</strong>ByteBuf 提供一个<code>聚合视图</code>。比如HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuf，将会在消息被发送的时候<code>组装</code>为<strong>一个 ByteBuf</strong>，此时可以将这两个 ByteBuf <code>聚合</code>为一个 <code>CompositeByteBuf</code>，然后使用统一和通用的 <code>ByteBuf API</code> 来操作。</p><h3 id="4-9-3-分配方式"><a href="#4-9-3-分配方式" class="headerlink" title="4.9.3 分配方式"></a>4.9.3 分配方式</h3><p>如何在我们的程序中获得 <code>ByteBuf 的实例</code>，并使用它呢？Netty 提供了<strong>两种方式</strong>。</p><ul><li>按需分配：ByteBufAllocator 接口</li></ul><p>Netty的一种实例分配池化接口。通过 <code>interface ByteBufAllocator</code> 分配我们所描述过的<code>任意类型</code>的 <code>ByteBuf 实例</code>。</p><p>下表列出了<code>ByteBufAllocator</code>提供的一些操作。</p><table border="0" cellpadding="0" cellspacing="0" width="889" style="border-collapse:collapse;table-layout:fixed;width:667pt"><colgroup><col width="429" style="mso-width-source:userset;mso-width-alt:13738;width:322pt"><col width="460" style="mso-width-source:userset;mso-width-alt:14720;width:345pt"><tr height="24" style="height:18pt"><td height="24" class="xl65" width="429" style="height:18pt;width:322pt"><font class="font7">名称</font></td><td class="xl65" width="460" style="width:345pt"><font class="font7">描述</font></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt"><div title="Page 90">buffer();</div></td><td rowspan="3" class="xl65"><font class="font7">返回一个基于堆或者直接内存存储的</font> <font class="font6">ByteBuf</font></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">buffer(int initialCapacity);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">buffer(int initialCapacity, int maxCapacity);<span style="mso-spacerun:yes"></span></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt"><div title="Page 90">heapBuffer();</div></td><td rowspan="3" class="xl65"><font class="font7">返回一个基于堆内存存储的</font><font class="font6">ByteBuf</font></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">heapBuffer(int initialCapacity);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">heapBuffer(int initialCapacity, int maxCapacity);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt"><div title="Page 90">directBuffer();</div></td><td rowspan="3" class="xl65"><div title="Page 90"><font class="font8">返回一个基于直接内存存储的</font><font class="font6">ByteBuf</font></div></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">directBuffer(int initialCapacity);</td></tr><tr height="25" style="height:19pt"><td height="25" class="xl66" width="429" style="height:19pt;width:322pt">directBuffer(int initialCapacity, int maxCapacity);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt"><div title="Page 90">compositeBuffer();</div></td><td rowspan="6" class="xl67" width="460" style="width:345pt"><font class="font8">返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的</font> <font class="font6">CompositeByteBuf<span style="mso-spacerun:yes"></span></font></td></tr><tr height="25" style="height:19pt"><td height="25" class="xl66" width="429" style="height:19pt;width:322pt">compositeBuffer(int maxNumComponents);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">compositeDirectBuffer();</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">compositeDirectBuffer(int maxNumComponents);</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">compositeHeapBuffer();</td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt">compositeHeapBuffer(int maxNumComponents);<span style="mso-spacerun:yes"></span></td></tr><tr height="24" style="height:18pt"><td height="24" class="xl65" style="height:18pt"><div title="Page 90">ioBuffer()<span style="mso-spacerun:yes"></span></div></td><td class="xl65"><font class="font8">返回一个用于套接字的</font> <font class="font6">I/O</font> <font class="font8">操作的</font> <font class="font6">ByteBuf<span style="mso-spacerun:yes"></span></font></td></tr><tr height="0" style="display:none"><td width="429" style="width:322pt"></td><td width="460" style="width:345pt"></td></tr></colgroup></table><p>可以通过 <code>Channel</code>(每个都可以有一个不同的 <code>ByteBufAllocator</code> 实例)或者绑定到 <code>ChannelHandler</code> 的 <code>ChannelHandlerContext</code> 获取一个到 <code>ByteBufAllocator</code> 的<code>引用</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 Channel 获取一个到 ByteBufAllocator 的引用</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">ChannelHandlerContext</span> ctx <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBufAllocator</span> allocator2 <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>两种ByteBufAllocator的实现</p><ul><li>PooledByteBufAllocator（默认）：<code>池化</code>了<code>ByteBuf</code>的实例以提高性能并最大限度地减少内存碎片。</li><li>UnpooledByteBufAllocator：实现<code>不池化</code>ByteBuf实例，并且在每次它被调用时都会返回一个<code>新的实例</code>。</li></ul></blockquote><ul><li>Unpooled 缓冲区<br>Netty 提供了一个简单的称为 Unpooled 的工具类<code>ByteBufUtil</code>，它提供了<code>静态</code>的辅助方法来创建<code>未池化</code>的 ByteBuf 实例。</li></ul><p><code>Unpooled 类</code>还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的<code>非网络项目</code>， 使得其能得益于高性能的可扩展的缓冲区 API。</p><h3 id="4-9-4-字节级操作"><a href="#4-9-4-字节级操作" class="headerlink" title="4.9.4 字节级操作"></a>4.9.4 字节级操作</h3><h4 id="4-9-4-1-随机访问索引"><a href="#4-9-4-1-随机访问索引" class="headerlink" title="4.9.4.1 随机访问索引"></a>4.9.4.1 随机访问索引</h4><p>类似java的字节数组遍历。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">byte</span> b <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是，使用那些需要<code>一个索引值参数</code>的方法(的其中)之一来访问数据既<code>不会改变 readerIndex</code> 也<code>不会改变 writerIndex</code>。如果有需要，也可以通过调用 <code>readerIndex(index)</code> 或者 <code>writerIndex(index)</code>来手动移动这两者。</p></blockquote><h4 id="4-9-4-2-顺序访问索引"><a href="#4-9-4-2-顺序访问索引" class="headerlink" title="4.9.4.2 顺序访问索引"></a>4.9.4.2 顺序访问索引</h4><p>虽然 ByteBuf 同时具有<code>读索引</code>和<code>写索引</code>，但是 JDK 的 <code>ByteBuffer</code> 却只有<code>一个索引</code>，这 也就是为什么必须调用 <code>flip()</code>方法来在<code>读模式</code>和<code>写模式</code>之间进行切换的原因。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ByteBuf-Inner-Segments.png"><div class="caption"><b class="center-caption">ByteBuf的内部分段</b></div><h4 id="4-9-4-3-可丢弃字节"><a href="#4-9-4-3-可丢弃字节" class="headerlink" title="4.9.4.3 可丢弃字节"></a>4.9.4.3 可丢弃字节</h4><p><code>可丢弃字节的分段</code>包含了已经<code>被读过</code>的字节。通过调用 <code>discardReadBytes()</code>方法，可以<code>丢弃</code>它们并<code>回收空间</code>。这个分段的初始大小为 0，存储在 <code>readerIndex</code> 中，会随着 <code>read</code> 操作的执行而增加(get*操作不会移动 readerIndex)。</p><p>缓冲区上调用 <code>discardReadBytes()</code>方法后，<code>可丢弃字节分段</code>中的空间已经变为<code>可写</code>的了。 频繁地调用 <code>discardReadBytes()</code>方法以确保可写分段的最大化，但是<strong>请注意</strong>，这将极有可能会导致<code>内存复制</code>，因为<code>可读字节</code>必须被移动到缓冲区的开始位置。建议只在有真正需要的时候才这样做，例如，当内存非常宝贵的时候。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/discardReadBytes-ByteBuf.png"><div class="caption"><b class="center-caption">丢弃已读字节之后的 ByteBuf</b></div><h4 id="4-9-4-4-可读字节"><a href="#4-9-4-4-可读字节" class="headerlink" title="4.9.4.4 可读字节"></a>4.9.4.4 可读字节</h4><p>ByteBuf 的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的 <code>readerIndex</code> 值为 0。</p><h4 id="4-9-4-5-可写字节"><a href="#4-9-4-5-可写字节" class="headerlink" title="4.9.4.5 可写字节"></a>4.9.4.5 可写字节</h4><p>可写字节分段是指一个拥有<code>未定义内容的</code>、<code>写入就绪的</code>内存区域。新分配的缓冲区的 <code>writerIndex</code> 的默认值为 0。任何名称以 <code>write 开头</code>的操作都将从当前的 <code>writerIndex</code> 处开始 写数据，并将它增加已经写入的字节数。</p><h4 id="4-9-4-6-索引管理"><a href="#4-9-4-6-索引管理" class="headerlink" title="4.9.4.6 索引管理"></a>4.9.4.6 索引管理</h4><p>调用 <code>markReaderIndex()</code>、<code>markWriterIndex()</code>、<code>resetWriterIndex()</code>和 <code>resetReaderIndex()</code>来<code>标记</code>和<code>重置</code> ByteBuf 的 <code>readerIndex</code> 和 <code>writerIndex</code>。</p><p>也可以通过调用 <code>readerIndex(int)</code>或者 <code>writerIndex(int)</code>来将索引移动到指定位置。试图将任何一个索引设置到一个<code>无效的</code>位置都将导致一个 <code>IndexOutOfBoundsException</code>。</p><p>可以通过调用 <code>clear()</code>方法来将 <code>readerIndex</code> 和 <code>writerIndex</code> 都设置为 0。注意，这并<code>不会清除</code>内存中的内容。</p><h4 id="4-9-4-7-查找操作"><a href="#4-9-4-7-查找操作" class="headerlink" title="4.9.4.7 查找操作"></a>4.9.4.7 查找操作</h4><p>在 <code>ByteBuf</code> 中有多种可以用来确定指定值的索引的方法。最简单的是使用 <code>indexOf()</code>方法。较复杂的查找可以通过调用 <code>forEachByte()</code>。<br>代码展示了一个查找回车符(\r)的例子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">forEachByte</span><span class="token punctuation">(</span><span class="token class-name">ByteBufProcessor</span><span class="token punctuation">.</span><span class="token constant">FIND_CR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-9-4-8-派生缓冲区"><a href="#4-9-4-8-派生缓冲区" class="headerlink" title="4.9.4.8 派生缓冲区"></a>4.9.4.8 派生缓冲区</h4><p>派生缓冲区为 ByteBuf 提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方法被创建的:</p><ul><li>duplicate();</li><li>slice();</li><li>slice(int, int);</li><li>Unpooled.unmodifiableBuffer(…);</li><li>order(ByteOrder);</li><li>readSlice(int)。</li></ul><p>每个这些方法都将返回一个<code>新的 ByteBuf 实例</code>，它具有自己的<code>读索引</code>、<code>写索引</code>和<code>标记索引</code>。其内部存储和 JDK 的 <code>ByteBuffer</code> 一样也是<code>共享的</code>。</p><blockquote><p><code>ByteBuf 复制</code>如果需要一个现有缓冲区的真实副本，请使用 <code>copy()</code>或者 <code>copy(int, int)</code>方法。不同于派生缓冲区，由这个调用所返回的 <code>ByteBuf</code> 拥有<code>独立的数据副本</code>。</p></blockquote><h4 id="4-9-4-9-引用计数"><a href="#4-9-4-9-引用计数" class="headerlink" title="4.9.4.9 引用计数"></a>4.9.4.9 引用计数</h4><p><code>引用计数</code>是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第4 版中为ByteBuf引入了引用计数技术， <code>interface ReferenceCounted</code>。</p><h4 id="4-9-4-10-资源释放"><a href="#4-9-4-10-资源释放" class="headerlink" title="4.9.4.10 资源释放"></a>4.9.4.10 资源释放</h4><p>当某个 <code>ChannelInboundHandler</code> 的实现<code>重写 channelRead()</code>方法时，它要负责<strong>显式地</strong>释放与池化的 <code>ByteBuf 实例</code>相关的内存。</p><p>Netty 为此提供了一个实用方法 <code>ReferenceCountUtil.release()</code>。</p><p>Netty 将使用 <code>WARN 级别</code>的<code>日志消息</code>记录<code>未释放</code>的资源，使得可以非常简单地在代码中发现违规的实例。但是以这种方式管理资源可能<code>很繁琐</code>。一个更加简单的方式是使用 <code>SimpleChannelInboundHandler</code>，它会<code>自动释放</code>资源。</p><ul><li><p>对于<code>入站请求</code>，Netty 的 <code>EventLoop</code> 在处理 Channel 的<code>读操作</code>时进行分配 ByteBuf，对于这类 ByteBuf，需要我们自行进行释放，有三种方式：</p><ul><li>使用 <code>SimpleChannelInboundHandler</code></li><li>在<code>重写 channelRead()</code>方法使用 <code>ReferenceCountUtil.release()</code></li><li>使用 <code>ctx.fireChannelRead</code> 继续向后传递;</li></ul></li><li>对于<code>出站请求</code>，不管 ByteBuf 是否由我们的业务创建的，当调用了 <code>write</code> 或者 <code>writeAndFlush</code> 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。</li></ul><p>下一个章节将举个栗子，初识下Netty的应用基础用法。</p><p>参考资料：</p><ul><li>《Netty in Action》</li></ul></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Kezade</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://zyxelva.github.io/posts/1355578097.html">https://zyxelva.github.io/posts/1355578097.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Kezade</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Netty/"><span class="chip bg-color">Netty</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.twikoo-card{margin:1.5rem auto}.twikoo-card .card-content{padding:20px}#tcomments textarea{box-sizing:border-box;background:url("/") 100% 100% no-repeat}#tcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem;text-align:left}#tcomments blockquote p{text-indent:.2rem}#tcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#tcomments img{max-width:100%;height:auto;cursor:pointer}#tcomments ol li{list-style-type:decimal}#tcomments ol,ul{display:block;padding-left:2em;word-spacing:0.05rem}#tcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#tcomments ul li{list-style-type:disc}#tcomments ul ul li{list-style-type:circle}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#tcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#tcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#tcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#tcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#tcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#tcomments h6{font-size:1rem;line-height:1.3rem}#tcomments p{font-size:1rem;line-height:1.5rem}#tcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#tcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#tcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#tcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#tcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#tcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#tcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#tcomments b,strong{font-weight:700}#tcomments dfn{font-style:italic}#tcomments small{font-size:85%}#tcomments cite{font-style:normal}#tcomments mark{background-color:#fcf8e3;padding:.2em}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card twikoo-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div class="card-content" style="display:grid"><div id="tcomments"></div></div></div><script src="https://gcore.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://kezadetwikoo.netlify.app/.netlify/functions/twikoo",el:"#tcomments",region:"",path:""}).then(function(){for(var t=document.querySelector("#twikoo").getElementsByTagName("input"),e=0;e<t.length;e++)t[e]&&t[e].classList.add("browser-default")})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/1478672774.html"><div class="card-image"><img src="/medias/Netty.png" class="responsive-img" alt="【Netty学习】4.Netty的一个例子"> <span class="card-title">【Netty学习】4.Netty的一个例子</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-05-22</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Netty%E5%AD%A6%E4%B9%A0/" class="post-category">Netty学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Netty/"><span class="chip bg-color">Netty</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/1837626065.html"><div class="card-image"><img src="/medias/Netty.png" class="responsive-img" alt="【Netty学习】2.Java原生网络编程"> <span class="card-title">【Netty学习】2.Java原生网络编程</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-05-18</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Netty%E5%AD%A6%E4%B9%A0/" class="post-category">Netty学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Netty/"><span class="chip bg-color">Netty</span></a> <a href="/tags/BIO/"><span class="chip bg-color">BIO</span></a> <a href="/tags/NIO/"><span class="chip bg-color">NIO</span></a> <a href="/tags/AIO/"><span class="chip bg-color">AIO</span></a> <a href="/tags/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><span class="chip bg-color">IO多路复用</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: Kezade<br />文章作者: Kezade<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeBlockFuction.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeLang.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeCopy.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h1, h2, h3, h4, h5"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const o="expanded";let n=$("#toc-aside"),i=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){n.hasClass(o)?(n.removeClass(o).hide(),i.removeClass("l9")):(n.addClass(o).show(),i.addClass("l9")),function(t,e){let o=$("#"+t);if(0===o.length)return;let n=o.width();n+=n>=450?21:n>=350&&n<450?18:n>=300&&n<350?16:14,$("#"+e).width(n)}("artDetail","prenext-posts")})})</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <a href="/about" target="_blank">Kezade</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=6e4,t=36e5,n=864e5,a=365*n,i=new Date,r="2019",o=i.getFullYear(),s=i.getMonth()+1,l=i.getDate(),m=i.getHours(),c=i.getMinutes(),d=i.getSeconds(),g=Date.UTC(r,"6","28","0","0","0"),h=Date.UTC(o,s,l,m,c,d)-g,u=Math.floor(h/a),M=Math.floor(h/n-365*u),T=Math.floor((h-(365*u+M)*n)/t),f=Math.floor((h-(365*u+M)*n-T*t)/e),y=Math.floor((h-(365*u+M)*n-T*t-f*e)/1e3);if(r===String(o)){document.getElementById("year").innerHTML=o;var v="This site has been running for "+M+" days";v="本站已运行 "+M+" 天",document.getElementById("sitetime").innerHTML=v}else{document.getElementById("year").innerHTML=r+" - "+o;var H="This site has been running for "+u+" years and "+M+" days "+T+" hours "+f+" mins "+y+" seconds";H="本站已苟且偷生 "+u+" 年 "+M+" 天 "+T+" 小时 "+f+" 分钟 "+y+" 秒",document.getElementById("sitetime").innerHTML=H}};calcSiteTime(),setInterval(calcSiteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/zyxelva" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:zyxelva@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1807401971" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1807401971" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a> <a href="https://www.zhihu.com/people/kezade" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kezade" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="../rss2.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach(function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach(function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))}),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach(function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")}),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}}),t+="</ul>",s.innerHTML=t)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/masonry/masonry.pkgd.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/js/matery.js"></script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/background/ribbon-dynamic.js" async></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/instantpage/instantpage.js" type="module"></script></body></html>