<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="【Redis学习】1.常用的数据结构, Back-End Dev Java"><meta name="description" content="1 前言Redis提供了丰富的数据类型，常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。
随着Redis版本的更新，后面又支持了四种数据类型：BitMap（2.2版新增）、Hy"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>【Redis学习】1.常用的数据结构 | Kezade</title><link rel="icon" type="image/jpeg" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg"><style>body{background-image:url(https://it-ark-dev.oss-cn-shenzhen.aliyuncs.com/464e9ac7a5a729ae67f91f7cf0cf6fe2.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:cover;background-position:center center}</style><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/animate/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.1/css/matery.css?v3"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/my.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/post.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/reward.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/jquery/jquery-3.6.0.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.3/js/function.js?v88"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/imgStatus.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/waterfall.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/lately.min.js"></script><script>var memos={host:"https://s.dusays.com/",limit:"10",creatorId:"49",username:"zyxelva",name:"Kezade",domId:"#memos",path:"api/v1/memo"},douban={api:"https://douban-api.edui.fun/"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="Kezade" type="application/rss+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img k-avatar" alt="LOGO"> <span class="logo-span">Kezade</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-newspaper" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:0.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-sitemap" style="zoom:0.6"></i> <span>系列</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/categories/%E7%AE%97%E6%B3%95"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>考研</span></a></li><li><a href="/categories/OSSD"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>高考</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-place-of-worship" style="zoom:0.6"></i> <span>我的</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:0.6"></i> <span>相册</span></a></li><li><a href="/bibi"><i class="fa-fw fa-solid fa-cloud-rain" style="margin-top:-20px;zoom:0.6"></i> <span>哔哔</span></a></li><li><a href="/todolist"><i class="fa-fw fa-solid fa-circle-check" style="margin-top:-20px;zoom:0.6"></i> <span>清单</span></a></li><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:0.6"></i> <span>音乐</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-circle-info" style="zoom:0.6"></i> <span>更多</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:0.6"></i> <span>留言</span></a></li><li><a href="/friends"><i class="fa-solid fa-link" style="margin-top:-20px;zoom:0.6"></i> <span>友链</span></a></li><li><a href="/friend-circle"><i class="fa-solid fa-rss" style="margin-top:-20px;zoom:0.6"></i> <span>圈圈</span></a></li><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:0.6"></i> <span>关于</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img circle responsive-img"><div class="logo-name">Kezade</div><div class="logo-desc">7 年 Java 开发经验，其中 3 年以上大型系统架构设计经验，以及 2 年以上的团队管理经验 | 具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验 | 对 Zookeeper、Netty、Dubbo、Spring Cloud、 Spring 等开源框架源码有过深入研究，并且有一定的框架定制开发经验</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-newspaper"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-sitemap"></i> 系列<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/categories/%E7%AE%97%E6%B3%95" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>考研</span></a></li><li><a href="/categories/OSSD" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>高考</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-place-of-worship"></i> 我的<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/bibi" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-cloud-rain" style="position:absolute;left:50px"></i> <span>哔哔</span></a></li><li><a href="/todolist" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-circle-check" style="position:absolute;left:50px"></i> <span>清单</span></a></li><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-circle-info"></i> 更多<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="/friends" style="margin-left:75px"><i class="fa fa-solid fa-link" style="position:absolute;left:50px"></i> <span>友链</span></a></li><li><a href="/friend-circle" style="margin-left:75px"><i class="fa fa-solid fa-rss" style="position:absolute;left:50px"></i> <span>圈圈</span></a></li><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/cryptojs/crypto-js.min.js"></script><script></script><style>:root{--post-bg-image:url('https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/featureimages/6.jpg')}</style><div class="bg-cover pd-header post-cover"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">【Redis学习】1.常用的数据结构</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="chip bg-color">数据结构</span></a> <a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis%E5%AD%A6%E4%B9%A0/" class="post-category">Redis学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-08-24</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 6.8k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 25 分</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>Redis提供了丰富的数据类型，常见的有<code>五种</code>：<code>String</code>（字符串），<code>Hash</code>（哈希），<code>List</code>（列表），<code>Set</code>（集合）、<code>Zset</code>（有序集合）。</p><p>随着Redis版本的更新，后面又支持了<code>四种</code>数据类型：<code>BitMap</code>（2.2版新增）、<code>HyperLogLog</code>（2.8版新增）、<code>GEO</code>（3.2版新增）、<code>Stream</code>（5.0版新增）。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Data-Structure.png"></p><div class="caption"><b class="center-caption">Redis数据结构一览</b></div><p></p><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><p>Redis中所有的<code>值对象</code>内部定义都是<code>redisObject</code>结构体。结构如下图：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Object-Structure.png"></p><div class="caption"><b class="center-caption">RedisObject结构体示意图</b></div><p></p><p>源码结构体：<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//server.h</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">&#123;</span>
　　<span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
　　<span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
　　<span class="token keyword">unsigned</span> lru<span class="token operator">:</span>REDIS_LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* lru time (relative to server.lruclock) */</span>
　　<span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
　　<span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>各字段说明如下表：</p><div class="table-container"><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>存储对象的类型，Redis中有5中数据类型：<code>String</code>，<code>List</code>，<code>Hash</code>，<code>Set</code>，<code>Zset</code>，可以通过 <code>type &#123;key&#125;</code>命令查看对象的类型，返回的是值对象类型，所有的key对象都是<code>String类型</code></td></tr><tr><td>encoding</td><td>数据存储的Redis中后采用的是那种内部编码格式，这个后边会细讲一下</td></tr><tr><td>lru</td><td>记录的是对象被最后一次访问的时间，当配置了<code>maxmemory</code>之后，配合<code>LRU算法</code>对相关的key值进行删除，可以通过<code>object idletime &#123;key&#125;</code>查看key最近一次被访问的时间。也可以通过<code>scan + object idletime</code>命令批量查询那些键长时间没有被使用，从而可以删除长时间没有被使用的键值，减少内存的占用。</td></tr><tr><td>refcount</td><td>记录当前对象被引用的次数。根据当前字段来判断该对象时候可回收，当<code>refcount</code>为0时，可安全进行对象的回收，可以使用<code>object refcount &#123;key&#125;</code>查看当前对象引用。</td></tr><tr><td>*ptr</td><td>与对象的数据内容有关。如果是整数，则直接存储数据（这个地方可以了解下共享对象池，当对象为<code>整数</code>且范围在<code>【0-9999】</code>，会直接存储到共享对象池中），其他类型的数据次字段则代表的是<code>指针</code>。</td></tr></tbody></table></div><h2 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h2><h3 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h3><p><code>String</code>是redis中最基本的数据类型，一个<code>key</code>对应一个<code>value</code>。value可以是<code>String</code>、<code>List</code>、<code>Set</code>、<code>Sorted Set</code>、<code>hash</code>、<code>数字</code>、<code>二进制</code>（图片、音频、视频）等，最大不能超过<code>512M</code>。</p><h3 id="2-1-2-Redis简单动态字符串-SDS"><a href="#2-1-2-Redis简单动态字符串-SDS" class="headerlink" title="2.1.2 Redis简单动态字符串(SDS)"></a>2.1.2 Redis简单动态字符串(SDS)</h3><p>Redis没有直接使用<code>C语言</code>传统的字符串表示（以空字符结尾的字符数组，以下简称<code>C字符串</code>），而是自己构建了一种名为<code>简单动态字符串</code>（simple dynamic string，SDS）的抽象类型，并将<code>SDS</code>用作Redis的<code>默认字符串</code>表示。</p><p>每个<code>sds.h/sdshdr</code>结构表示一个SDS值：<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 记录 buf 数组中已使用字节的数量</span>
    <span class="token comment">// 等于 SDS 所保存字符串的长度</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>

    <span class="token comment">// 记录 buf 数组中未使用字节的数量</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span>

    <span class="token comment">// 字节数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><code>SDS</code>遵循<code>C字符串</code>以<code>空字符</code>结尾的惯例，保存空字符的<code>1字节</code>空间不计算在SDS的<code>len</code>属性里面，并且为<code>空字符</code>分配额外的<code>1字节</code>空间，以及添加空字符到字符串末尾等操作都是由<code>SDS函数</code>自动完成的，所以这个空字符对于SDS的使用者来说是<code>完全透明的</code>。</p><h3 id="2-1-3-内部编码"><a href="#2-1-3-内部编码" class="headerlink" title="2.1.3 内部编码"></a>2.1.3 内部编码</h3><p>字符串对象的<code>内部编码</code>（encoding）有3种：<code>int</code>、<code>raw</code>和<code>embstr</code>。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-String-InnerStructure.jpg"></p><div class="caption"><b class="center-caption">字符串类型的内部编码</b></div><p></p><p>可通过下面的命令查看当前String类型的内部编码：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis<span class="token operator">></span> SET number <span class="token number">10086</span>
OK

redis<span class="token operator">></span> OBJECT ENCODING number
<span class="token string">"int"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-SDS-Example.png"></p><div class="caption"><b class="center-caption">SDS样例</b></div><br>+<code>free</code>属性的值为<code>0</code>，表示这个SDS没有分配任何未使用空间。<br>+<code>len</code>属性的值为<code>5</code>，表示这个SDS保存了一个<code>五字节</code>长的字符串。<br>+<code>buf</code>属性是一个<code>char类型</code>的数组，数组的前五个字节分别保存了’R’、’e’、’d’、’i’、’s’五个字符，而最后一个字节则保存了空字符’\0’。<p></p><p>另一个实例，主要说明<code>free</code>属性的作用：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-SDS-Example3.png"></p><div class="caption"><b class="center-caption">SDS样例2</b></div><p></p><ul><li>这个SDS和之前展示的SDS一样，都保存了字符串值<code>&quot;Redis&quot;</code>。</li><li>这个SDS和之前展示的SDS的区别在于，这个SDS为<code>buf数组</code>分配了<code>五字节</code><strong>未使用空间</strong>，所以它的<code>free</code>属性的值为<code>5</code>（图中使用五个空格来表示五字节的未使用空间）。</li></ul><ul><li><p>如果一个字符串对象保存的是<code>整数值</code>，并且这个整数值可以用<code>long类型</code>来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将void*转换成long），并将字符串对象的编码设置为<code>int</code>。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-String-INT.png"><div class="caption"><b class="center-caption">编码类型为int</b></div></li><li><p>如果字符串对象保存的是一个<code>字符串</code>，并且这个字符申的长度<code>小于等于32字节</code>（redis 2.+版本），那么字符串对象将使用一个<code>简单动态字符串</code>来保存这个字符串，并将对象的编码设置为<code>embstr</code>，embstr编码是专门用于保存短字符串的一种优化编码方式：</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-String-embstr.png"><div class="caption"><b class="center-caption">编码类型为embstr</b></div></li><li><p>如果字符串对象保存的是一个<code>字符串</code>，并且这个字符串的长度<code>大于32字节</code>（redis 2.+版本），那么字符串对象将使用一个<code>简单动态字符串</code>来保存这个字符串，并将对象的编码设置为<code>raw</code>：</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-String-raw.png"><div class="caption"><b class="center-caption">编码类型为raw</b></div></li></ul><p>至于<code>embstr</code>和<code>raw</code>，读者可能有疑问，为啥<code>RedisObject</code>与<code>sdshdr</code>一个挨着，一个分开？</p><blockquote><p><code>embstr编码</code>是专门用于保存<code>短字符串</code>的一种优化编码方式，这种编码和<code>raw编码</code>一样，都使用<code>redisObject</code>结构和<code>sdshdr</code>结构来表示字符串对象，但<code>raw编码</code>会调用<strong>两次内存分配函数</strong>来分别创建<code>redisObject结构</code>和<code>sdshdr结构</code>，而<code>embstr编码</code>则通过调用<strong>一次内存分配函数</strong>来分配一块连续的空间，空间中依次包含<code>redisObject</code>和<code>sdshdr</code>两个结构.</p></blockquote><p><code>embstr编码</code>的字符串对象在执行命令时，产生的效果和<code>raw编码</code>的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：</p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的<code>两次降低为一次</code>。</li><li>释放embstr编码的字符串对象只需要调用<strong>一次内存释放函数</strong>，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><blockquote><p>注意，<code>embstr编码</code>和<code>raw编码</code>的<strong>边界</strong>在redis不同版本中是不一样的：</p><ul><li>redis 2.+是32字节</li><li>redis 3.0-4.0是39字节</li><li>redis 5.0是44字节</li></ul></blockquote><p>但是<code>embstr</code>也有缺点的：</p><blockquote><p>如果字符串的长度增加需要重新分配内存时，整个<code>redisObject</code>和<code>sdshdr</code>都需要重新分配空间，所以<code>embstr编码</code>的字符串对象实际上是只读的，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行<code>任何修改命令</code>（例如append）时，程序会先将对象的编码<code>从embstr转换成raw</code>，然后再执行修改命令。</p></blockquote><h3 id="2-1-4-常用命令"><a href="#2-1-4-常用命令" class="headerlink" title="2.1.4 常用命令"></a>2.1.4 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th><code>int</code>编码的实现方法</th><th><code>embstr</code>编码的实现方法</th><th><code>raw</code>编码的实现方法</th></tr></thead><tbody><tr><td>SET</td><td>使用<code>int</code>编码保存值。</td><td>使用<code>embstr</code>编码保存值。</td><td>使用<code>raw</code>编码保存值。</td></tr><tr><td>GET</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后向客户端返回这个字符串值。</td><td>直接向客户端返回字符串值。</td><td>直接向客户端返回字符串值。</td></tr><tr><td>APPEND</td><td>将对象转换成<code>raw</code>编码，然后按<code>raw</code>编码的方式执行此操作。</td><td>将对象转换成<code>raw</code>编码，然后按<code>raw</code>编码的方式执行此操作。</td><td>调用<code>sdscatlen</code>函数，将给定字符串追加到现有字符串的末尾。</td></tr><tr><td>INCRBYFLOAT</td><td>取出整数值并将其转换成<code>longdouble</code>类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。</td><td>取出字符串值并尝试将其转换成<code>longdouble</code>类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串值不能被转换成浮点数，那么向客户端返回一个错误。</td><td>取出字符串值并尝试将其转换成<code>longdouble</code>类型的浮点数，对这个浮点数进行加法计算，然后将得出的浮点数结果保存起来。如果字符串值不能被转换成浮点数，那么向客户端返回一个错误。</td></tr><tr><td>INCRBY</td><td>对整数值进行加法计算，得出的计算结果会作为整数被保存起来。</td><td><code>embstr</code>编码不能执行此命令，向客户端返回一个错误。</td><td><code>raw</code>编码不能执行此命令，向客户端返回一个错误。</td></tr><tr><td>DECRBY</td><td>对整数值进行减法计算，得出的计算结果会作为整数被保存起来。</td><td><code>embstr</code>编码不能执行此命令，向客户端返回一个错误。</td><td><code>raw</code>编码不能执行此命令，向客户端返回一个错误。</td></tr><tr><td>STRLEN</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，计算并返回这个字符串值的长度。</td><td>调用<code>sdslen</code>函数，返回字符串的长度。</td><td>调用<code>sdslen</code>函数，返回字符串的长度。</td></tr><tr><td>SETRANGE</td><td>将对象转换成<code>raw</code>编码，然后按<code>raw</code>编码的方式执行此命令。</td><td>将对象转换成<code>raw</code>编码，然后按<code>raw</code>编码的方式执行此命令。</td><td>将字符串特定索引上的值设置为给定的字符。</td></tr><tr><td>GETRANGE</td><td>拷贝对象所保存的整数值，将这个拷贝转换成字符串值，然后取出并返回字符串指定索引上的字符。</td><td>直接取出并返回字符串指定索引上的字符。</td><td>直接取出并返回字符串指定索引上的字符。</td></tr></tbody></table></div><h3 id="2-1-5-应用场景"><a href="#2-1-5-应用场景" class="headerlink" title="2.1.5 应用场景"></a>2.1.5 应用场景</h3><p>缓存，计数，共享session，限速</p><h2 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h2><h3 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h3><p><code>Hash</code>是一个键值对（key - value）集合，其中 <code>value</code> 的形式如：<code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于<code>存储对象</code>。</p><p><code>Hash</code> 与 <code>String</code> 对象的区别如下图所示：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-String-and-Hash-Diff.png"></p><div class="caption"><b class="center-caption">Hash和String存储区别</b></div><p></p><h3 id="2-2-2-内部编码"><a href="#2-2-2-内部编码" class="headerlink" title="2.2.2 内部编码"></a>2.2.2 内部编码</h3><p>Hash 类型的底层数据结构是由<code>压缩列表</code>(ziplist)或<code>哈希表</code>(hashtable)实现的：</p><ul><li>如果哈希类型<strong>元素个数</strong><code>小于 512 个</code>（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），且所有值<code>小于 64 字节</code>（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<code>压缩列表</code>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<code>哈希表</code>作为 Hash 类型的底层数据结构。<blockquote><p>在 <code>Redis 7.0</code> 中，压缩列表数据结构已经废弃了，交由 <code>listpack</code> 数据结构来实现了。</p></blockquote></li></ul><h3 id="2-2-3-ziplist"><a href="#2-2-3-ziplist" class="headerlink" title="2.2.3 ziplist"></a>2.2.3 ziplist</h3><p><code>ziplist</code>是为了提高存储效率而设计的一种特殊编码的<code>双向链表</code>。它可以存储<code>字符串</code>或者<code>整数</code>，存储整数时是采用整数的<code>二进制</code>而不是字符串形式存储。它能在<code>O(1)</code>的时间复杂度下完成list两端的<code>push</code>和<code>pop</code>操作。但是因为每次操作都需要<code>重新分配ziplist的内存</code>，所以实际复杂度和ziplist的内存使用量相关。<br>其结构<sup><a href="#fn_1" id="reffn_1">1</a></sup>大致如下：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Ziplist-Structure.png"></p><div class="caption"><b class="center-caption">ziplist组成结构一览</b></div><p></p><p>压缩列表各个组成部分的详细说明</p><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entryX<sup><a href="#fn_2" id="reffn_2">2</a></sup></td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table></div><p>压缩列表节点(<code>entry</code>)包含三部分内容：</p><ul><li><code>prevlen</code>，记录了「前一个节点」的长度，目的是为了实现<code>从后向前遍历</code>；</li><li><code>encoding</code>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：<code>字符串</code>和<code>整数</code>。</li><li><code>data</code>，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</li></ul><ul><li><p>优点：节省内存<br>当我们往压缩列表中插入数据时，压缩列表就会根据<code>数据类型是字符串还是整数</code>，以及<code>数据的大小</code>，会使用不同空间大小的 <code>prevlen</code> 和 <code>encoding</code> 这两个元素里保存的信息，这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的。</p></li><li><p>缺点：</p><ul><li>查找复杂度高</li><li>连锁更新：压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。<sup><a href="#fn_3" id="reffn_3">3</a></sup></li></ul></li></ul><h3 id="2-2-4-hashtable"><a href="#2-2-4-hashtable" class="headerlink" title="2.2.4 hashtable"></a>2.2.4 hashtable</h3><p>Redis 的哈希表结构如下：<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//哈希表数组</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token comment">//哈希表大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>  
    <span class="token comment">//哈希表大小掩码，用于计算索引值</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token comment">//该哈希表已有的节点数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> dictht<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>可以看到，哈希表是一个数组（<code>dictEntry **table</code>），数组的每个元素是一个指向「哈希表节点（<code>dictEntry</code>）」的指针。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Hashtable-dictht.jpg"></p><div class="caption"><b class="center-caption">hashtable结构一览</b></div><p></p><p>dictEntry 结构定义如下：<br><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//键</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token comment">//值</span>
    <span class="token keyword">union</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_tu64<span class="token punctuation">;</span>
        int64_ts64<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>v<span class="token punctuation">;</span>

    <span class="token comment">//指向下一个哈希表节点，形成链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>dictEntry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>dictEntry</code>结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是<code>链式哈希</code>。</p><p>另外，<code>dictEntry</code>结构里键值对中的<code>值</code>是一个<code>联合体 v</code>定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个<code>无符号的 64 位整数</code>或<code>有符号的 64 位整数</code>或<code>double 类的值</code>。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</p><h3 id="2-2-5-常用命令"><a href="#2-2-5-常用命令" class="headerlink" title="2.2.5 常用命令"></a>2.2.5 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td><code>HSET hash-key sub-key1 value1</code></td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td><code>HGET hash-key key1</code></td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td><code>HGETALL hash-key</code></td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td><code>HDEL hash-key sub-key1</code></td></tr></tbody></table></div><h3 id="2-2-6-应用场景"><a href="#2-2-6-应用场景" class="headerlink" title="2.2.6 应用场景"></a>2.2.6 应用场景</h3><p>缓存对象、购物车</p><h2 id="2-3-list"><a href="#2-3-list" class="headerlink" title="2.3 list"></a>2.3 list</h2><h3 id="2-3-1-介绍"><a href="#2-3-1-介绍" class="headerlink" title="2.3.1 介绍"></a>2.3.1 介绍</h3><p><code>List列表</code>是简单的字符串列表，按照插入顺序排序，列表元素可重复，最多$2^{32}$-1个元素。可以从<code>头部</code>或<code>尾部</code>向 List 列表添加元素。</p><h3 id="2-3-2-内部编码"><a href="#2-3-2-内部编码" class="headerlink" title="2.3.2 内部编码"></a>2.3.2 内部编码</h3><p>List 类型的底层数据结构是由<code>双向链表</code>(linkedlist)或<code>压缩列表</code>(ziplist)实现的：</p><ul><li>如果列表的<strong>元素个数</strong><code>小于 512 个</code>（默认值，可由 <code>list-max-ziplist-entries</code>配置），且列表每个元素的<code>值</code>都<code>小于 64 字节</code>（默认值，可由<code>list-max-ziplist-value</code>配置），Redis 会使用<code>压缩列表</code>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<code>双向链表</code>作为 List 类型的底层数据结构；<br>但是在 <code>Redis 3.2</code>版本之后，List 数据类型底层数据结构就只由 <code>quicklist</code><sup><a href="#fn_4" id="reffn_4">4</a></sup>实现了，替代了双向链表和压缩列表。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Quicklist.jpg"><div class="caption"><b class="center-caption">QuickList</b></div></li></ul><h3 id="2-3-3-常用命令"><a href="#2-3-3-常用命令" class="headerlink" title="2.3.3 常用命令"></a>2.3.3 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。也可以使用<code>负数</code>下标，以<code>-1</code>表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推。</td><td>LINDEX key index</td></tr></tbody></table></div><blockquote><p>使用列表的技巧</p><ul><li>lpush+lpop=Stack（栈）</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul></blockquote><h3 id="2-3-4-应用场景"><a href="#2-3-4-应用场景" class="headerlink" title="2.3.4 应用场景"></a>2.3.4 应用场景</h3><p>消息队列、微博TimeLine。</p><h2 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a>2.4 set</h2><h3 id="2-4-1-介绍"><a href="#2-4-1-介绍" class="headerlink" title="2.4.1 介绍"></a>2.4.1 介绍</h3><p>与list最大不同，set集合内元素唯一且无序。一个集合最多可以存储 $2^{32}$-1 个元素。概念和数学中个的<code>集合</code>基本类似，可以<code>交集</code>，<code>并集</code>，<code>差集</code>等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><blockquote><p>潜在的风险。Set 的差集、并集和交集的计算复杂度较高，在<code>数据量较大</code>的情况下，如果直接执行这些计算，会导致 Redis 实例<code>阻塞</code>。</p></blockquote><h3 id="2-4-2-内部编码"><a href="#2-4-2-内部编码" class="headerlink" title="2.4.2 内部编码"></a>2.4.2 内部编码</h3><p>Set 类型的底层数据结构是由<code>哈希表</code>或<code>整数集合</code><sup><a href="#fn_5" id="reffn_5">5</a></sup>实现的：</p><ul><li>如果集合中的元素都是<code>整数</code>且<code>元素个数小于 512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<code>整数集合</code>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<code>哈希表</code>作为 Set 类型的底层数据结构。</li></ul><h3 id="2-4-3-常用命令"><a href="#2-4-3-常用命令" class="headerlink" title="2.4.3 常用命令"></a>2.4.3 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBERS</td><td>返回集合中的所有成员</td><td>SMEMBERS key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table></div><h3 id="2-4-4-应用场景"><a href="#2-4-4-应用场景" class="headerlink" title="2.4.4 应用场景"></a>2.4.4 应用场景</h3><p>点赞、标签、共同关注、抽奖活动。</p><h2 id="2-5-zset"><a href="#2-5-zset" class="headerlink" title="2.5 zset"></a>2.5 zset</h2><h3 id="2-5-1-介绍"><a href="#2-5-1-介绍" class="headerlink" title="2.5.1 介绍"></a>2.5.1 介绍</h3><p>Redis<code>有序集合</code>(Zset)和集合(set)一样也是 string 类型元素的集合，且<code>不允许重复</code>的成员。不同的是每个元素都会关联一个 <code>double</code>类型的<code>分数</code>。redis 正是通过<code>分数</code>来为集合中的成员进行从小到大的<code>排序</code>。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-SortedSet.jpg"></p><div class="caption"><b class="center-caption">zset存储结构</b></div><p></p><h3 id="2-5-2-内部编码"><a href="#2-5-2-内部编码" class="headerlink" title="2.5.2 内部编码"></a>2.5.2 内部编码</h3><p><code>Zset</code>类型的底层数据结构是由<code>压缩列表</code>或<code>跳表</code>实现的：</p><ul><li>如果有序集合的元素个数<code>小于 128 个</code>，并且每个元素的<code>值</code>均<code>小于 64 字节</code>时，Redis 会使用<code>压缩列表</code>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<code>跳表</code><sup><a href="#fn_6" id="reffn_6">6</a></sup>作为 Zset 类型的底层数据结构；<blockquote><p>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 <code>listpack</code> 数据结构来实现了.</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Skiplist.jpg"><div class="caption"><b class="center-caption">跳表结构示意图</b></div></blockquote></li></ul><h3 id="2-5-3-常用命令"><a href="#2-5-3-常用命令" class="headerlink" title="2.5.3 常用命令"></a>2.5.3 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table></div><h3 id="2-5-4-应用场景"><a href="#2-5-4-应用场景" class="headerlink" title="2.5.4 应用场景"></a>2.5.4 应用场景</h3><ul><li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul><h2 id="2-6-位图"><a href="#2-6-位图" class="headerlink" title="2.6 位图"></a>2.6 位图</h2><h3 id="2-6-1-介绍"><a href="#2-6-1-介绍" class="headerlink" title="2.6.1 介绍"></a>2.6.1 介绍</h3><p><code>Bitmap</code>，即位图数据结构，都是操作二进制位来进行记录，只有<code>0</code>和<code>1</code>两个状态。</p><p>BitMap通过最小的单位<code>bit</code>来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为<code>O(1)</code>。</p><h3 id="2-6-2-内部实现"><a href="#2-6-2-内部实现" class="headerlink" title="2.6.2 内部实现"></a>2.6.2 内部实现</h3><p>Bitmap 本身是用 <code>String 类型</code>作为底层数据结构实现的一种<code>统计二值状态</code>的数据类型。</p><p>String 类型是会保存为<code>二进制</code>的<code>字节数组</code>，所以，Redis 就把字节数组的每个 <code>bit</code> 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 <code>bit 数组</code>。</p><h3 id="2-6-3-常用命令"><a href="#2-6-3-常用命令" class="headerlink" title="2.6.3 常用命令"></a>2.6.3 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SETBIT</td><td>设定key对应value，其中value为0或1，不能为其他值</td><td>SETBIT key offset value</td></tr><tr><td>GETBIT</td><td>获取key对应的value</td><td>GETBIT key offset</td></tr><tr><td>BITCOUNT</td><td>获取指定范围内值为 1 的个数，start 和 end 以字节为单位</td><td>BITCOUNT key start end</td></tr><tr><td>BITPOS</td><td>返回指定key中第一次出现指定value(0/1)的位置</td><td>BITPOS [key] [value]</td></tr></tbody></table></div><h3 id="2-6-4-应用场景"><a href="#2-6-4-应用场景" class="headerlink" title="2.6.4 应用场景"></a>2.6.4 应用场景</h3><p>签到、打卡、判断用户登陆态、连续签到用户总数</p><h2 id="2-7-GEO"><a href="#2-7-GEO" class="headerlink" title="2.7 GEO"></a>2.7 GEO</h2><h3 id="2-7-1-介绍"><a href="#2-7-1-介绍" class="headerlink" title="2.7.1 介绍"></a>2.7.1 介绍</h3><p>Redis 的 GEO 在 <code>Redis 3.2</code> 版本就推出了! 这个功能可以推算地理位置的信息: <strong>两地之间的距离, 方圆几里的人</strong>.</p><h3 id="2-7-2-内部实现"><a href="#2-7-2-内部实现" class="headerlink" title="2.7.2 内部实现"></a>2.7.2 内部实现</h3><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了<code>Sorted Set</code>集合类型。</p><p>GEO 类型使用 <code>GeoHash 编码</code>方法实现了<code>经纬度</code>到<code>Sorted Set</code>中元素权重分数的转换，这其中的两个关键机制就是<code>「对二维地图做区间划分」</code>和<code>「对区间进行编码」</code>。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为<code>Sorted Set</code>元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到<code>Sorted Set</code>中，利用<code>Sorted Set</code>提供的<code>“按权重进行有序范围查找”</code>的特性，实现 LBS 服务中频繁使用的<code>“搜索附近”</code>的需求。</p><h3 id="2-7-3-常用命令"><a href="#2-7-3-常用命令" class="headerlink" title="2.7.3 常用命令"></a>2.7.3 常用命令</h3><p>参见<a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html#geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE">geospatial (地理位置)</a></p><h3 id="2-7-4-应用场景"><a href="#2-7-4-应用场景" class="headerlink" title="2.7.4 应用场景"></a>2.7.4 应用场景</h3><p>滴滴叫车.</p><h2 id="2-8-HyperLogLog"><a href="#2-8-HyperLogLog" class="headerlink" title="2.8 HyperLogLog"></a>2.8 HyperLogLog</h2><h3 id="2-8-1-介绍"><a href="#2-8-1-介绍" class="headerlink" title="2.8.1 介绍"></a>2.8.1 介绍</h3><p>Redis <code>HyperLogLog</code>是 <code>Redis 2.8.9</code> 版本新增的数据类型，是一种用于<code>「统计基数」</code>的数据集合类型，基数统计就是指统计一个集合中<code>不重复</code>的元素个数。但要注意，HyperLogLog 是统计规则是基于<code>概率</code>完成的，不是非常准确，标准误算率是 <code>0.81%</code>。</p><blockquote><p>基数统计，举个例子，<code>A = &#123;1, 2, 3, 4, 5&#125;</code>， <code>B = &#123;3, 5, 6, 7, 9&#125;</code>；那么基数（不重复的元素）= <code>1, 2, 4, 6, 7, 9</code>； （允许容错，即可以接受一定误差）。<br>所以，简单来说 HyperLogLog 提供<code>不精确的去重计数</code>。</p></blockquote><ul><li>优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。<blockquote><p>一个大型的网站，每天 IP 比如有<code>100万</code>，粗算一个 IP 消耗<code>15 字节</code>，那么<code>100万</code>个 IP 就是<code>15M</code>。而 HyperLogLog 在 Redis 中每个键占用的内容都是<code>12K</code>，理论存储近似接近 $2^{64}$ 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 <code>0.81%</code> 标准错误的<code>近似值</code>（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p></blockquote></li></ul><h3 id="2-8-2-内部实现"><a href="#2-8-2-内部实现" class="headerlink" title="2.8.2 内部实现"></a>2.8.2 内部实现</h3><p>参见<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog内部原理</a>.</p><h3 id="2-8-3-常用命令"><a href="#2-8-3-常用命令" class="headerlink" title="2.8.3 常用命令"></a>2.8.3 常用命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>PFADD</td><td>添加指定元素到 HyperLogLog 中</td><td>PFADD key element [element …]</td></tr><tr><td>PFCOUNT</td><td>返回给定 HyperLogLog 的基数估算值。</td><td>PFCOUNT key [key …]</td></tr><tr><td>PFMERGE</td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td><td>PFMERGE destkey sourcekey [sourcekey …]</td></tr></tbody></table></div><h3 id="2-8-4-应用场景"><a href="#2-8-4-应用场景" class="headerlink" title="2.8.4 应用场景"></a>2.8.4 应用场景</h3><p>百万级网页 UV 计数。</p><h2 id="2-9-Stream"><a href="#2-9-Stream" class="headerlink" title="2.9 Stream"></a>2.9 Stream</h2><h3 id="2-9-1-介绍"><a href="#2-9-1-介绍" class="headerlink" title="2.9.1 介绍"></a>2.9.1 介绍</h3><p>Redis <code>Stream</code>是<code>Redis 5.0</code>版本新增加的数据类型，Redis 专门为<code>消息队列</code>设计的数据类型。</p><p>基于Redis的<code>消息队列</code>实现有很多种，例如：</p><ul><li><code>PUB/SUB</code>，发布/订阅模式，但是发布订阅模式是<code>无法持久化</code>的，如果出现网络断开、Redis 宕机等，消息就会被丢弃；并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>基于List <code>LPUSH + BRPOP</code> 或者基于<code>Sorted-Set</code>的实现，支持了持久化，但是<code>不支持多播，分组消费</code>等。</li></ul><p>基于以上问题，<code>Redis 5.0</code>便推出了<code>Stream</code>类型也是此版本最重要的功能，用于完美地实现<code>消息队列</code>，它支持消息的<code>持久化</code>、支持自动生成<code>全局唯一 ID</code>、支持<code>ack 确认消息</code>的模式、支持<code>消费组模式</code>等，让消息队列更加的稳定和可靠。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Stream-Structure.jpg"></p><div class="caption"><b class="center-caption">Stream结构</b></div><p></p><h3 id="2-9-2-常见命令"><a href="#2-9-2-常见命令" class="headerlink" title="2.9.2 常见命令"></a>2.9.2 常见命令</h3><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>XADD</td><td>插入消息（尾插），保证有序，可以自动生成全局唯一 ID；</td><td>xadd codehole * key value key value</td></tr><tr><td>XLEN</td><td>查询消息长度；</td><td>xlen codehole</td></tr><tr><td>XREAD</td><td>用于读取消息，可以按 ID 读取数据；</td><td>XREAD STREAMS mymq 1654254953807-0</td></tr><tr><td>XDEL</td><td>根据消息 ID 删除消息；</td><td>xdel codehole 1527849609889-0</td></tr><tr><td>DEL</td><td>删除整个 Stream；</td><td>del codehole # 删除整个Stream</td></tr><tr><td>XGROUP</td><td>创建消费者组</td><td>创建一个名为 <code>group1</code> 的消费组，<code>0-0</code>表示从<code>第一条</code>消息开始读取。XGROUP CREATE mymq group1 0-0</td></tr><tr><td>XRANGE</td><td>读取区间消息</td><td></td></tr><tr><td>XREADGROUP</td><td>按消费组形式读取消息；</td><td></td></tr><tr><td>XPENDING</td><td>命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</td><td>XPENDING mymq group2</td></tr><tr><td>XACK</td><td>命令用于向消息队列确认消息处理已完成；</td><td>XACK mymq group2 1654256265584-0</td></tr></tbody></table></div><blockquote><p>注：<code>xadd</code>中，*号表示服务器<code>自动生成ID</code>，后面顺序跟着一堆<code>key/value</code>；<br><code>XREAD</code>从这个消息 ID 的<code>下一条消息</code>开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入ID的消息）；</p></blockquote><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Redis-Stream-Flow.jpg"><div class="caption"><b class="center-caption">Stream流程</b></div><p>更多命令参考<a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">pdai</a>、<a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/command.html#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-2">小林coding</a>.</p><h3 id="2-9-3-应用场景"><a href="#2-9-3-应用场景" class="headerlink" title="2.9.3 应用场景"></a>2.9.3 应用场景</h3><p>消息队列</p><h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3 参考文献"></a>3 参考文献</h1><p><sup><a href="#fn_1" id="reffn_1">1</a></sup> <a target="_blank" rel="noopener" href="https://www.w3cschool.cn/hdclil/avdu2ozt.html">ziplist结构</a><br><sup><a href="#fn_2" id="reffn_2">2</a></sup> <a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html">entry结构</a><br><sup><a href="#fn_3" id="reffn_3">3</a></sup> <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0">连锁更新</a><br><sup><a href="#fn_4" id="reffn_4">4</a></sup> <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html#quicklist-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">QuickList</a><br><sup><a href="#fn_5" id="reffn_5">5</a></sup> <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88">整数集合</a><br><sup><a href="#fn_6" id="reffn_6">6</a></sup> <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/data_struct.html#%E8%B7%B3%E8%A1%A8">跳表</a></p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Kezade</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://zyxelva.github.io/posts/3971932782.html">https://zyxelva.github.io/posts/3971932782.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Kezade</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="chip bg-color">数据结构</span></a> <a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.twikoo-card{margin:1.5rem auto}.twikoo-card .card-content{padding:20px}#tcomments textarea{box-sizing:border-box;background:url("/") 100% 100% no-repeat}#tcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem;text-align:left}#tcomments blockquote p{text-indent:.2rem}#tcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#tcomments img{max-width:100%;height:auto;cursor:pointer}#tcomments ol li{list-style-type:decimal}#tcomments ol,ul{display:block;padding-left:2em;word-spacing:0.05rem}#tcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#tcomments ul li{list-style-type:disc}#tcomments ul ul li{list-style-type:circle}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#tcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#tcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#tcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#tcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#tcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#tcomments h6{font-size:1rem;line-height:1.3rem}#tcomments p{font-size:1rem;line-height:1.5rem}#tcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#tcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#tcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#tcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#tcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#tcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#tcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#tcomments b,strong{font-weight:700}#tcomments dfn{font-style:italic}#tcomments small{font-size:85%}#tcomments cite{font-style:normal}#tcomments mark{background-color:#fcf8e3;padding:.2em}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card twikoo-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div class="card-content" style="display:grid"><div id="tcomments"></div></div></div><script src="https://gcore.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://kezadetwikoo.netlify.app/.netlify/functions/twikoo",el:"#tcomments",region:"",path:""}).then(function(){for(var t=document.querySelector("#twikoo").getElementsByTagName("input"),e=0;e<t.length;e++)t[e]&&t[e].classList.add("browser-default")})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/2249264199.html"><div class="card-image"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/featureimages/6.jpg" class="responsive-img" alt="【Redis学习】2.持久化"> <span class="card-title">【Redis学习】2.持久化</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-08-28</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Redis%E5%AD%A6%E4%B9%A0/" class="post-category">Redis学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Redis/"><span class="chip bg-color">Redis</span></a> <a href="/tags/AOF/"><span class="chip bg-color">AOF</span></a> <a href="/tags/RDB/"><span class="chip bg-color">RDB</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/218005482.html"><div class="card-image"><img src="/medias/RocketMQ2.png" class="responsive-img" alt="【RocketMQ学习】16.SpringBoot整合RocketMQ实战"> <span class="card-title">【RocketMQ学习】16.SpringBoot整合RocketMQ实战</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-08-22</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0/" class="post-category">RocketMQ学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/RocketMQ%E5%AE%9E%E6%88%98/"><span class="chip bg-color">RocketMQ实战</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: Kezade<br />文章作者: Kezade<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeBlockFuction.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeLang.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeCopy.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h1, h2, h3, h4, h5"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const o="expanded";let n=$("#toc-aside"),i=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){n.hasClass(o)?(n.removeClass(o).hide(),i.removeClass("l9")):(n.addClass(o).show(),i.addClass("l9")),function(t,e){let o=$("#"+t);if(0===o.length)return;let n=o.width();n+=n>=450?21:n>=350&&n<450?18:n>=300&&n<350?16:14,$("#"+e).width(n)}("artDetail","prenext-posts")})})</script></main><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <a href="/about" target="_blank">Kezade</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=6e4,t=36e5,n=864e5,a=365*n,i=new Date,r="2019",o=i.getFullYear(),s=i.getMonth()+1,l=i.getDate(),m=i.getHours(),c=i.getMinutes(),d=i.getSeconds(),g=Date.UTC(r,"6","28","0","0","0"),h=Date.UTC(o,s,l,m,c,d)-g,u=Math.floor(h/a),M=Math.floor(h/n-365*u),T=Math.floor((h-(365*u+M)*n)/t),f=Math.floor((h-(365*u+M)*n-T*t)/e),y=Math.floor((h-(365*u+M)*n-T*t-f*e)/1e3);if(r===String(o)){document.getElementById("year").innerHTML=o;var v="This site has been running for "+M+" days";v="本站已运行 "+M+" 天",document.getElementById("sitetime").innerHTML=v}else{document.getElementById("year").innerHTML=r+" - "+o;var H="This site has been running for "+u+" years and "+M+" days "+T+" hours "+f+" mins "+y+" seconds";H="本站已苟且偷生 "+u+" 年 "+M+" 天 "+T+" 小时 "+f+" 分钟 "+y+" 秒",document.getElementById("sitetime").innerHTML=H}};calcSiteTime(),setInterval(calcSiteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/zyxelva" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:zyxelva@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1807401971" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1807401971" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a> <a href="https://www.zhihu.com/people/kezade" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kezade" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="../rss2.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach(function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach(function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))}),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach(function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")}),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}}),t+="</ul>",s.innerHTML=t)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/masonry/masonry.pkgd.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/js/matery.js"></script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/background/ribbon-dynamic.js" async></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/instantpage/instantpage.js" type="module"></script></body></html>