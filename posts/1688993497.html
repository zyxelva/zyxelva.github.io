<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="【JVM学习】4.垃圾回收机制及算法, Back-End Dev Java"><meta name="description" content="1 定义垃圾收集器(Garbage Collector，下文简称GC)。
程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；
栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>【JVM学习】4.垃圾回收机制及算法 | Kezade</title><link rel="icon" type="image/jpeg" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg"><style>body{background-image:url(https://it-ark-dev.oss-cn-shenzhen.aliyuncs.com/464e9ac7a5a729ae67f91f7cf0cf6fe2.jpg);background-repeat:no-repeat;background-attachment:fixed;background-size:cover;background-position:center center}</style><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/awesome/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/animate/animate.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.1/css/matery.css?v3"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/my.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/post.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/css/reward.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/jquery/jquery-3.6.0.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v3.3/js/function.js?v88"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/imgStatus.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/waterfall.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/picgo@v1.3/js/lately.min.js"></script><script>var memos={host:"https://s.dusays.com/",limit:"10",creatorId:"49",username:"zyxelva",name:"Kezade",domId:"#memos",path:"api/v1/memo"},douban={api:"https://douban-api.edui.fun/"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="Kezade" type="application/rss+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img k-avatar" alt="LOGO"> <span class="logo-span">Kezade</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-newspaper" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:0.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-sitemap" style="zoom:0.6"></i> <span>系列</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/categories/%E7%AE%97%E6%B3%95"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>考研</span></a></li><li><a href="/categories/OSSD"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83"><i class="fa-solid fa-rocket" style="margin-top:-20px;zoom:0.6"></i> <span>高考</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-place-of-worship" style="zoom:0.6"></i> <span>我的</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:0.6"></i> <span>相册</span></a></li><li><a href="/bibi"><i class="fa-fw fa-solid fa-cloud-rain" style="margin-top:-20px;zoom:0.6"></i> <span>哔哔</span></a></li><li><a href="/todolist"><i class="fa-fw fa-solid fa-circle-check" style="margin-top:-20px;zoom:0.6"></i> <span>清单</span></a></li><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:0.6"></i> <span>音乐</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fa-solid fa-circle-info" style="zoom:0.6"></i> <span>更多</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:0.6"></i> <span>留言</span></a></li><li><a href="/friends"><i class="fa-solid fa-link" style="margin-top:-20px;zoom:0.6"></i> <span>友链</span></a></li><li><a href="/friend-circle"><i class="fa-solid fa-rss" style="margin-top:-20px;zoom:0.6"></i> <span>圈圈</span></a></li><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:0.6"></i> <span>关于</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/avatar/avatar2.jpg" class="logo-img circle responsive-img"><div class="logo-name">Kezade</div><div class="logo-desc">7 年 Java 开发经验，其中 3 年以上大型系统架构设计经验，以及 2 年以上的团队管理经验 | 具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验 | 对 Zookeeper、Netty、Dubbo、Spring Cloud、 Spring 等开源框架源码有过深入研究，并且有一定的框架定制开发经验</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-newspaper"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-sitemap"></i> 系列<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/categories/%E7%AE%97%E6%B3%95" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>算法学习</span></a></li><li><a href="/categories/RocketMQ%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>RMQ学习</span></a></li><li><a href="/categories/Netty%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Netty学习</span></a></li><li><a href="/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Spring学习</span></a></li><li><a href="/categories/JVM%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>JVM学习</span></a></li><li><a href="/categories/MySQL%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MySQL学习</span></a></li><li><a href="/categories/MyBatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>MyBatis学习</span></a></li><li><a href="/categories/Zookeeper%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>ZK学习</span></a></li><li><a href="/categories/Hexo" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Hexo学习</span></a></li><li><a href="/categories/Redis%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Redis学习</span></a></li><li><a href="/categories/Docker%E5%AD%A6%E4%B9%A0" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>Docker学习</span></a></li><li><a href="/categories/AP-Calculus" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>AP学习</span></a></li><li><a href="/categories/A-Level" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>A-Level学习</span></a></li><li><a href="/categories/SAT" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>SAT学习</span></a></li><li><a href="/categories/%E8%80%83%E7%A0%94" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>考研</span></a></li><li><a href="/categories/OSSD" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>OSSD</span></a></li><li><a href="/categories/%E9%AB%98%E8%80%83" style="margin-left:75px"><i class="fa fa-solid fa-rocket" style="position:absolute;left:50px"></i> <span>高考</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-place-of-worship"></i> 我的<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/bibi" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-cloud-rain" style="position:absolute;left:50px"></i> <span>哔哔</span></a></li><li><a href="/todolist" style="margin-left:75px"><i class="fa fa-fw fa-solid fa-circle-check" style="position:absolute;left:50px"></i> <span>清单</span></a></li><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fa-solid fa-circle-info"></i> 更多<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="/friends" style="margin-left:75px"><i class="fa fa-solid fa-link" style="position:absolute;left:50px"></i> <span>友链</span></a></li><li><a href="/friend-circle" style="margin-left:75px"><i class="fa fa-solid fa-rss" style="position:absolute;left:50px"></i> <span>圈圈</span></a></li><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于</span></a></li></ul></li><li><div class="divider"></div></li><li><a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/cryptojs/crypto-js.min.js"></script><script></script><style>:root{--post-bg-image:url('https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/JVM.png')}</style><div class="bg-cover pd-header post-cover"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">【JVM学习】4.垃圾回收机制及算法</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span></a> <a href="/tags/GC%E7%AE%97%E6%B3%95/"><span class="chip bg-color">GC算法</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" class="post-category">JVM学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-06-28</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 9.5k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 34 分</div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h1><p><code>垃圾收集器</code>(Garbage Collector，下文简称GC)。</p><p><code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code><strong>随线程而生，也随线程而灭</strong>；</p><p><code>栈帧</code>随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有<code>确定性</code>，在这几个区域内不需要过多考虑回收的问题，<strong>因为方法结束或者线程结束时，内存自然就跟随着回收了</strong>。</p><p>而对于 <code>Java 堆</code>和<code>方法区</code>，我们只有在程序<code>运行期间</code>才能知道会创建哪些对象，这部分内存的分配和回收都是<code>动态的</code>，<code>GC</code>所关注的正是这部分内存。</p><h1 id="2-回收对象"><a href="#2-回收对象" class="headerlink" title="2 回收对象"></a>2 回收对象</h1><p>即哪些对象是GC的目标，也就是如何判定对象是否不可用或者说已死。</p><p>JVM说：若一个对象不被任何对象或变量<code>引用</code>，那么它就是<code>无效对象</code>，需要被回收。</p><p>常用的判定方法有：引用计数法、可达性分析法。</p><h2 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h2><p>判定对象是否存活都和<code>引用</code>离不开关系。</p><p>在<code>JDK 1.2版之前</code>，Java里面的<code>引用</code>是很传统的定义：如果<code>reference类型</code>的数据中存储的数值代表的是另外一块内存的<code>起始地址</code>，就称该<code>reference数据</code>是代表<strong>某块内存、某个对象的引用</strong>。</p><p>在<code>JDK 1.2版之后</code>，Java对引用的概念进行了<code>扩充</code>，将引用分为<code>强引用</code>(Strongly Reference)、<code>软引用</code>(Soft Reference)、<code>弱引用</code>(Weak Reference)和<code>虚引用</code>(Phantom Reference)4种，这4种引用强度依次<code>逐渐减弱</code>。</p><h3 id="2-1-1-强引用"><a href="#2-1-1-强引用" class="headerlink" title="2.1.1 强引用"></a>2.1.1 强引用</h3><p>类似<code>Object obj=new Object()</code>这种引用关系。</p><blockquote><p>无论任何情况下，只要强引用关系还存在，垃圾收集器就<strong>永远不会</strong>回收掉被引用的对象。</p></blockquote><h3 id="2-2-2-软引用"><a href="#2-2-2-软引用" class="headerlink" title="2.2.2 软引用"></a>2.2.2 软引用</h3><p>用来描述一些<code>还有用</code>，<code>但非必须的对象</code>。</p><p>只被软引用关联着的对象，在系统将要<code>发生内存溢出异常前</code>，会把这些对象列进回收范围之中进行第二次回收，如果这次回收<strong>还没有足够的内存</strong>， 才会抛出<code>内存溢出异常</code>。</p><blockquote><p>在<code>JDK 1.2版之后</code>提供了<code>SoftReference类</code>来实现软引用。</p></blockquote><h3 id="2-2-3-弱引用"><a href="#2-2-3-弱引用" class="headerlink" title="2.2.3 弱引用"></a>2.2.3 弱引用</h3><p>也是用来描述那些<code>非必须对象</code>，但是它的强度比<code>软引用</code><strong>更弱一些</strong>，被<code>弱引用</code>关联的对象只能生存到<strong>下一次垃圾收集发生为止</strong>。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉<code>只被弱引用关联的对象</code>。</p><blockquote><p>在<code>JDK 1.2版之后</code>提供了<code>WeakReference类</code>来实现弱引用。</p></blockquote><h3 id="2-2-4-虚引用"><a href="#2-2-4-虚引用" class="headerlink" title="2.2.4 虚引用"></a>2.2.4 虚引用</h3><p>也称为<code>幽灵引用</code>或者<code>幻影引用</code>，它是<code>最弱的</code>一种引用关系。</p><p>一个对象是否有<code>虚引用</code>的存在，<strong>完全不会</strong>对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p><p>为一个对象设置虚引用关联的<code>唯一目的</code><strong>只是为了能在这个对象被收集器回收时收到一个系统通知</strong>。</p><blockquote><p>在<code>JDK 1.2版之后</code>提供 了<code>PhantomReference类</code>来实现虚引用。</p></blockquote><h2 id="2-2-引用计数法"><a href="#2-2-引用计数法" class="headerlink" title="2.2 引用计数法"></a>2.2 引用计数法</h2><p>在对象头维护着一个 <code>counter 计数器</code>，对象被引用一次则计数器 <code>+1</code>；若引用失效则计数器 <code>-1</code>。 当计数器为 <code>0</code> 时，就认为该对象无效了。</p><blockquote><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用<code>引用计数算法</code>来管理内存，主要是因为它<strong>很难解决对象之间循环引用的问题</strong>。</p></blockquote><h2 id="2-3-可达性分析法"><a href="#2-3-可达性分析法" class="headerlink" title="2.3 可达性分析法"></a>2.3 可达性分析法</h2><p>基本思路就是通过一系列称为<code>GC Roots</code>的<code>根对象</code>作为起始节点集，从这些节点开始，根据引用关系<code>向下搜索</code>，搜索过程所走过的路径称为<code>引用链</code>(Reference Chain)，如果某个对象到<code>GC Roots</code>间<strong>没有任何引用链相连</strong>， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象<code>不可达</code>时，则证明此对象是不可能再被使用的。</p><p>如图3-1所示，对象<code>object 5</code>、<code>object 6</code>、<code>object 7</code>虽然互有关联，但是它们到<code>GC Roots</code>是不可达的， 因此它们将会被判定为可回收的对象。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Reachability-Analysis.png"></p><div class="caption"><b class="center-caption">利用可达性分析算法判定对象是否可回收</b></div><p></p><blockquote><p><code>GC Roots</code> 的<code>对象</code>包括下面几种(<strong>重点是前面 4 种</strong>)：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>方法区中<code>类静态属性引用的对象</code>；java类的引用类型静态变量。</li><li>方法区中<code>常量引用的对象</code>，比如：字符串常量池里的引用。</li><li>本地方法栈中<code>JNI(即一般说的Native方法)引用的对象</code>。</li><li>JVM的内部引用(class对象、异常对象NullPointException、OutofMemoryError，系统类加载器)。</li><li>所有被同步锁(synchronized关键字)持有的对象。</li><li>JVM内部的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等。</li><li>JVM实现中的<code>临时性</code>对象，<code>跨代引用的对象</code>。</li></ul><p>Tips：<br>以上的回收都是<code>对象</code>，对于<code>类的回收条件</code>，请注意 Class 要被回收，条件比较苛刻，必须同时满足以下的条件(仅仅是可以，不代表必然，因为还有一些参数可以进行控制)：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class 对象</code>没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li><li>参数控制：<code>-Xnoclassgc</code>，禁用类的垃圾回收。</li></ul><p><code>废弃的常量和静态变量的回收</code>其实就和 <code>Class 回收</code>的条件差不多。比如常量池中<code>字面量回收</code>的例子，只要常量池中的常量不被任何变量或对象<code>引用</code>，那么这些常量就会被清除掉。如，一个字符串 “bingo” 进入了常量池，但是当前系统没有任何一个 <code>String 对象</code>引用常量池中的 “bingo” 常量，也没有其它地方引用这个字面量，必要的话，”bingo”常量会被清理出常量池。</p></blockquote><h2 id="2-4-回收堆中无效的对象"><a href="#2-4-回收堆中无效的对象" class="headerlink" title="2.4 回收堆中无效的对象"></a>2.4 回收堆中无效的对象</h2><p>可达性分析算法中判定为<code>不可达的对象</code>，也不是<code>非死不可</code>的。</p><p>它还会处于<code>缓刑</code>阶段，真正要宣告一个对象死亡，需要经过<code>两次标记</code>过程，一次是没有找到与 GCRoots 的引用链，它将被第一次标记。随后进行一次筛选(如果对象覆盖了 finalize)，我们可以在 finalize 中去拯救。</p><p>比如：在执行 <code>finalize()</code> 方法时，将 <code>this</code> 赋给了某一个引用，那么该对象就<code>重生</code>了。如果没有，那么就会被垃圾收集器<code>清除</code>。</p><p>如果这个对象被判定为确有必要执行<code>finalize()</code>方法，那么该对象将会被放置在一个名为<code>F-Queue</code>的<code>队列</code>之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<code>Finalizer线程</code>去执行它们的<code>finalize()</code>方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。</p><p>代码演示<code>拯救对象</code>，“你，只有一次机会”：<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeGC</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeGC</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am still alive!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize method executed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FinalizeGC</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>
        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//对象进行第1次GC</span>
        instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Finalizer 方法优先级很低，</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            instance<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am dead!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//对系选衍第2次GC</span>
        instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            instance<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am dead! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>运行结果：<br><pre class="line-numbers language-none"><code class="language-none">finalize method executed! 
I am still alive!
I am dead!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>可以看到，对象可以被拯救一次(<code>finalize</code> 执行第一次，但是<strong>不会</strong>执行第二次)。</p><p>代码改一下，再来一次：<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalizeGC</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">FinalizeGC</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am still alive!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize method executed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FinalizeGC</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>
        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalizeGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//对象进行第1次GC</span>
        instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 注释掉这行   Thread.sleep(1000); //Finalizer 方法优先级很低，</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            instance<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am dead! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//对象进行第2次GC</span>
        instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//注释掉这行 Thread. sleep (1000) ;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            instance<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am dead! "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>运行结果：<br><pre class="line-numbers language-none"><code class="language-none">I am dead!
finalize method executed! 
I am dead!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>对象没有被拯救，这个就是 <code>finalize</code> 方法执行缓慢，<strong>还没有完成拯救，垃圾收集器就已经回收掉了</strong>。</p><blockquote><p>所以建议大家尽量不要使用 <code>finalize</code>，因为这个方法<code>太不可靠</code>。在生产中你很难控制方法的执行或者对象的调用顺序，建议大家忘了 <code>finalize 方法</code>！因为在 <code>finalize 方法</code>能做的工作，java 中有更好的，比如 <code>try-finally</code> 或者其他方式可以做得更好。</p><p><code>System.gc();</code>只做测试，千万不要在实际生产中使用。不然，后果自负！</p></blockquote><h1 id="3-回收算法"><a href="#3-回收算法" class="headerlink" title="3 回收算法"></a>3 回收算法</h1><p>学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：</p><h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><ul><li>标记：遍历所有的 <code>GC Roots</code>，然后将所有 <code>GC Roots</code>可达的对象标记为<code>存活的对象</code> 。</li><li>清除：遍历堆中所有的对象，将<strong>没有标记的对象</strong>全部清除掉。与此同时，<code>清除</code>那些<strong>被标记过的对象的标记</strong>，以便下次的垃圾回收。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Mark-Sweep.png"><div class="caption"><b class="center-caption">“标记-清除”算法示意图</b></div>这种方法有两个不足：</li><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量<code>不连续的内存碎片</code>，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h2><p>常被简称为<code>复制算法</code>。</p><p>为了解决<code>效率问题</code>，“复制”收集算法出现了。它将可用内存按<code>容量</code>划分为<strong>大小相等的两块</strong>，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Mark-Copy.png"></p><div class="caption"><b class="center-caption">“标记-复制”算法示意图</b></div><p></p><p>这种算法有优有劣：</p><ul><li>优点：不会有内存碎片的问题。</li><li>缺点：内存缩小为原来的一半，浪费空间。</li></ul><p>为了解决<code>空间利用率问题</code>，可以将内存分为三块：<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>，比例是 <code>8:1:1</code>，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活的对象一次性复制到另外一块 <code>Survivor</code> 空间上，最后清理掉 <code>Eden</code> 和刚才使用的 <code>Survivor</code> 空间。这样只有 <code>10%</code> 的内存被浪费。</p><p>但是我们无法保证每次回收都只有不多于 <code>10%</code> 的对象存活，当 <code>Survivor</code> 空间不够，需要依赖其他内存(指老年代)进行<code>分配担保</code>。</p><blockquote><p>分配担保（Handle Promotion）：为对象分配内存空间时，如果 <code>Eden+Survivor</code> 中空闲区域无法装下该对象，会触发 <code>MinorGC</code> 进行垃圾收集。但如果 <code>Minor GC</code> 过后依然有超过 10% 的对象存活，这样存活的对象直接通过<code>分配担保机制</code>进入老年代，然后再将新对象存入 <code>Eden</code> 区。</p><p>内存的<code>分配担保</code>好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有什么风险了。</p></blockquote><h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><ul><li>标记：它的第一个阶段与<code>标记-清除</code>算法是一模一样的，均是遍历 <code>GC Roots</code>，然后将存活的对象标记。</li><li>整理：移动所有<code>存活的对象</code>，且按照内存地址次序依次排列，然后将<code>末端内存地址以后</code>的内存<code>全部回收</code>。因此，第二阶段才称为<code>整理阶段</code>。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Mark-Compact.png"><div class="caption"><b class="center-caption">“标记-整理”算法示意图</b></div><blockquote><p>这是一种<code>老年代</code>的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用<code>复制算法</code>，每次需要复制大量存活的对象，效率很低。</p></blockquote></li></ul><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>根据<code>对象存活周期的不同</code>，将内存划分为几块。一般是把 <code>Java 堆</code>分为<code>新生代</code>和<code>老年代</code>，针对各个年代的特点采用最适当的收集算法：</p><ul><li>新生代：复制算法</li><li>老年代：标记-清除算法、标记-整理算法。</li></ul><h1 id="4-Hotspot垃圾收集器"><a href="#4-Hotspot垃圾收集器" class="headerlink" title="4 Hotspot垃圾收集器"></a>4 Hotspot垃圾收集器</h1><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/GC-in-Hotspot.png"><div class="caption"><b class="center-caption">HotSpot虚拟机的垃圾收集器</b></div><h2 id="4-1-新生代"><a href="#4-1-新生代" class="headerlink" title="4.1 新生代"></a>4.1 新生代</h2><h3 id="4-1-1-Serial-垃圾收集器（单线程）"><a href="#4-1-1-Serial-垃圾收集器（单线程）" class="headerlink" title="4.1.1 Serial 垃圾收集器（单线程）"></a>4.1.1 Serial 垃圾收集器（单线程）</h3><p>最古老的，<code>单线程</code>，<code>独占式</code>，成熟，适合单 CPU，一般用在<code>客户端模式</code>下。</p><ul><li>优点：简单而高效；适合<code>几十兆</code>到<code>一两百兆</code>的<code>堆空间</code>进行垃圾回收(可以控制<code>停顿时间</code>在 <code>100ms</code> 左右)。</li><li>缺点：进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>（<code>Stop the world</code>，STW），直到它收集结束。</li><li>参数设置：<code>-XX:+UseSerialGC</code>， 新生代和老年代都用串行收集器。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Serial:Serial-Old.png"><div class="caption"><b class="center-caption">Serial/Serial Old垃圾收集器运行示意图</b></div></li></ul><blockquote><p>Tips：Stop The World(STW)(重点)<br><code>单线程</code>进行垃圾回收时，<strong>必须暂停所有的工作线程，直到它回收结束</strong>。这个暂停称之为“Stop The World”，但是这种 <code>STW</code> 带来了恶劣的用户体验，例如，应用每运行一个小时就需要暂停响应 5 分。这个也是早期 <code>JVM</code> 和 <code>java</code> 被 <code>C/C++语言</code>诟病性能差的一个重要原因。所以 JVM 开发团队一直努力消除或降低 STW 的时间。</p><h3 id="4-1-2-ParNew-垃圾收集器（多线程）"><a href="#4-1-2-ParNew-垃圾收集器（多线程）" class="headerlink" title="4.1.2 ParNew 垃圾收集器（多线程）"></a>4.1.2 ParNew 垃圾收集器（多线程）</h3><p>实质上是<code>Serial收集器</code>的<code>多线程并行版本</code>，除了同时使用多条线程进行垃圾收集之外，其余的行为包括<code>Serial收集器</code>可用的所有控制参数(例如：<code>-XX:SurvivorRatio</code>、<code>-XX:PretenureSizeThreshold</code>、<code>-XX:HandlePromotionFailure</code>等)、<code>收集算法</code>、<code>StopTheWorld</code>、<code>对象分配规则</code>、<code>回收策略</code>等都与<code>Serial收集器</code><strong>完全一致</strong>，在实现上这两种收集器也共用了相当多的代码。<br>在 JDK9 以后，把 <code>ParNew</code> 合并到了 <code>CMS</code> 了。</p></blockquote><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ParNew.png"><div class="caption"><b class="center-caption">ParNew垃圾收集器运行示意图</b></div><h3 id="4-1-3-Parallel-Scavenge-垃圾收集器（多线程）"><a href="#4-1-3-Parallel-Scavenge-垃圾收集器（多线程）" class="headerlink" title="4.1.3 Parallel Scavenge 垃圾收集器（多线程）"></a>4.1.3 Parallel Scavenge 垃圾收集器（多线程）</h3><p><code>Parallel Scavenge</code> 和 <code>ParNew</code> 一样，都是<code>多线程</code>、<code>新生代</code>垃圾收集器。但是两者有巨大的不同点：</p><ul><li><code>Parallel Scavenge</code>：追求 <code>CPU 吞吐量</code>，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li><li><code>ParNew</code>：追求<code>降低用户停顿时间</code>，适合交互式应用。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Parallel-Scavenge:Parallel-Old.png"><div class="caption"><b class="center-caption">Parallel Scavenge/Parallel Old垃圾收集器运行示意图</b></div></li></ul><blockquote><p><code>JDK1.8</code> 默认的新生代垃圾收集器。</p></blockquote><ul><li>参数设置<ul><li><code>-XX:GCTimeRadio</code>：设置垃圾回收时间占总 CPU 时间的百分比。</li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾处理过程最大停顿时间。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：开启自适应策略。我们只要设置好<code>堆的大小</code>和 <code>MaxGCPauseMillis</code> 或 <code>GCTimeRadio</code>，收集器会自动调整<code>新生代的大小</code>(-Xmn)、<code>Eden 和 Survivor 的比例</code>、<code>对象进入老年代的年龄</code>，以最大程度上接近我们设置的 <code>MaxGCPauseMillis</code> 或 <code>GCTimeRadio</code>。</li><li><code>-XX:+UseParallelGC</code>：新生代使用 <code>Parallel Scavenge</code>，老年代使用 <code>Parallel Old</code>。</li></ul></li></ul><blockquote><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote><h2 id="4-2-老年代"><a href="#4-2-老年代" class="headerlink" title="4.2 老年代"></a>4.2 老年代</h2><h3 id="4-2-1-Serial-Old-垃圾收集器（单线程）"><a href="#4-2-1-Serial-Old-垃圾收集器（单线程）" class="headerlink" title="4.2.1 Serial Old 垃圾收集器（单线程）"></a>4.2.1 Serial Old 垃圾收集器（单线程）</h3><p><code>Serial Old</code> 收集器是 <code>Serial</code> 的老年代版本，都是<code>单线程收集器</code>，只启用一条 GC 线程，都适合<code>客户端应用</code>。它们<strong>唯一的区别</strong>就是：<code>Serial Old</code> 工作在<strong>老年代</strong>，使用“标记-整理”算法；<code>Serial</code> 工作在<strong>新生代</strong>，使用“复制”算法。</p><h3 id="4-2-2-Parallel-Old-垃圾收集器（多线程）"><a href="#4-2-2-Parallel-Old-垃圾收集器（多线程）" class="headerlink" title="4.2.2 Parallel Old 垃圾收集器（多线程）"></a>4.2.2 Parallel Old 垃圾收集器（多线程）</h3><p><code>Parallel Old</code> 收集器是 <code>Parallel Scavenge</code> 的老年代版本，追求 CPU 吞吐量。</p><h3 id="4-2-3-CMS-垃圾收集器"><a href="#4-2-3-CMS-垃圾收集器" class="headerlink" title="4.2.3 CMS 垃圾收集器"></a>4.2.3 CMS 垃圾收集器</h3><p><code>CMS</code>(Concurrent Mark Sweep)收集器是一种以获取<code>最短回收停顿时间</code>为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注<code>服务的响应速度</code>，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p><p><code>CMS</code> 收集器是基于<code>标记-清除</code>算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 <code>4</code> 个步骤，包括：</p><ul><li>初始标记：短暂，仅仅只是标记一下 <code>GC Roots</code> 能<strong>直接关联</strong>到的对象，速度很快。</li><li>并发标记：和用户的应用程序同时进行，进行 <code>GC Roots</code> 追踪的过程，标记从 <code>GC Roots</code> 开始关联的所有对象开始遍历整个可达分析路径的对象。这个时间比较长，所以采用并发处理(垃圾收集器线程和用户线程同时工作)。</li><li>重新标记：短暂，为了<strong>修正</strong>并发标记期间因用户程序继续运作而导致<strong>标记产生变动</strong>的那一部分对象的标记记录，这个阶段的停顿时间一般会比<code>初始标记阶段</code>稍长一些，但远比<code>并发标记</code>的时间短。</li><li>并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</li></ul><p>由于整个过程中耗时最长的<code>并发标记</code>和<code>并发清除</code>过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起<code>并发执行</code>的。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/CMS.png"><div class="caption"><b class="center-caption">CMS垃圾收集器运行示意图</b></div><ul><li>缺点：<ul><li>吞吐量低</li><li>无法处理浮动垃圾，导致频繁 <code>Full GC</code></li><li>使用“标记-清除”算法产生<code>空间碎片</code></li></ul></li></ul><blockquote><p>对于产生<code>空间碎片</code>的问题，可以通过开启 <code>-XX:+UseCMSCompactAtFullCollection</code>，在每次 <code>Full GC</code> 完成后都会进行一次<code>内存压缩整理</code>，将零散在各处的对象整理到一块。设置参数 <code>- XX:CMSFullGCsBeforeCompaction</code>告诉 CMS，经过了 <code>N</code> 次 <code>Full GC</code> 之后再进行一次<code>内存整理</code>。</p></blockquote><ul><li>参数设置：在 <code>JDK1.8</code> 中，配置参数<code>-XX:UseConcMarkSweepGC</code>，启用<code>CMS</code>垃圾收集器。</li></ul><h2 id="4-3-G1-通用垃圾收集器（JDK7出现，JDK9默认）"><a href="#4-3-G1-通用垃圾收集器（JDK7出现，JDK9默认）" class="headerlink" title="4.3 G1 通用垃圾收集器（JDK7出现，JDK9默认）"></a>4.3 G1 通用垃圾收集器（JDK7出现，JDK9默认）</h2><p><code>G1</code> 是一款面向服务端应用的垃圾收集器，它<strong>没有新生代和老年代</strong>的概念，而是将<code>堆</code>划分为一块块独立的 <code>Region</code>。当要进行垃圾收集时，首先估计每个 <code>Region</code> 中垃圾的数量，每次都从垃圾回收价值最大的 <code>Region</code> 开始回收，因此可以获得最大的回收效率。</p><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/G1-Region.png"><div class="caption"><b class="center-caption">G1中的Region</b></div><ul><li><code>G1</code> 收集器的工作过程分为以下几个步骤：<ul><li>初始标记：<code>Stop The World</code>，仅使用一条初始标记线程对所有与 <code>GC Roots</code><strong>直接关联的对象</strong>进行标记。</li><li>并发标记：使用标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。</li><li>最终标记：<code>Stop The World</code>，使用多条标记线程并发执行。</li><li>筛选回收：回收废弃对象，此时也要 <code>Stop The World</code>，并使用多条筛选回收线程并发执行。</li></ul></li></ul><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/G1.png"><div class="caption"><b class="center-caption">G1垃圾收集器运行示意图</b></div><p>特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间<strong>不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</li><li><p>追求停顿时间：<code>-XX:MaxGCPauseMillis</code> 指定目标的最大停顿时间，G1 尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。</p></li><li><p>参数设置：</p><ul><li><code>-XX:+UseG1GC</code>：开启G1垃圾收集。</li><li><code>-XX:+G1HeapRegionSize</code>：分区大小。</li><li><code>-XX:MaxGCPauseMillis</code>：指定最大停顿时间（毫秒），默认没有最大停顿值。</li></ul></li></ul><h2 id="4-4-Shenandoah收集器"><a href="#4-4-Shenandoah收集器" class="headerlink" title="4.4 Shenandoah收集器"></a>4.4 Shenandoah收集器</h2><p>非Oracle亲生，由<code>RedHat</code>贡献给了<code>OpenJDK</code>，并推动它成为<code>OpenJDK 12</code>的正式特性之一。</p><p>这个项目的目标是实现一种能在<code>任何堆内存大小</code>下都可以把垃圾收集的<code>停顿时间</code>限制在<code>十毫秒以内</code>的垃圾收集器，该目标意味着相比<code>CMS</code>和<code>G1</code>，<code>Shenandoah</code>不仅要进行<code>并发的垃圾标记</code>，还要<code>并发地</code>进行对象清理后的<code>整理</code>动作。</p><p>具体的运行过程，可参考《深入理解Java虚拟机》第三版<code>Page 157</code>。这里只给出示意图：<br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Shenandoah.png"></p><div class="caption"><b class="center-caption">Shenandoah垃圾收集器运行示意图</b></div><p></p><ul><li>与<code>G1</code>的区别（管理堆内存方面）：<ul><li>支持并发的整理算法：<code>G1</code>的<strong>回收阶段</strong>是可以多线程并行的，但却<strong>不能</strong>与<code>用户线程</code><strong>并发</strong>，Shenandoah使用<code>转发指针</code>和<code>读屏障</code>来实现并发整理；</li><li>默认不使用<code>分代收集</code>，换言之，不会有专门的<code>新生代Region</code>或者<code>老年代Region</code>的存在；</li><li>无<code>记忆集</code>：改用名为<code>连接矩阵</code>(Connection Matrix)的全局数据结构来记录<code>跨Region的引用关系</code>，降低了处理跨代指针时的记忆集维护消耗，也降低了<code>伪共享问题</code>的发生概率。</li></ul></li></ul><blockquote><p>Tips：<br><code>伪共享</code>是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量<code>恰好共享同一个缓存行</code>，就会彼此影响(写回、无效化或者同步)而导致性能降低，这就是<code>伪共享问题</code>。</p></blockquote><h2 id="4-5-ZGC-JDK11开始"><a href="#4-5-ZGC-JDK11开始" class="headerlink" title="4.5 ZGC(JDK11开始)"></a>4.5 ZGC(JDK11开始)</h2><p><code>Z Garbage Collector</code>，即<code>ZGC</code>，是一款在<code>JDK 11</code>中新加入的具有实验性质的<code>低延迟垃圾收集器</code>，是由<code>Oracle公司</code>研发的。2018年Oracle创建了 <code>JEP 333</code>将<code>ZGC</code>提交给<code>OpenJDK</code>，推动其进入<code>OpenJDK 11</code>的发布清单之中。</p><p>同样是基于<code>Region内存布局</code>的，(暂时)不设分代的，使用了<code>读屏障</code>、<code>染色指针</code>和<code>内存多重映射</code>等技术来实现可并发的<code>标记-整理</code>算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>和<code>Shenandoah</code>的目标高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在<code>任意堆内存大小</code>下都可以把垃圾收集的停顿时间限制在<code>十毫秒以内</code>的低延迟。但是<code>ZGC</code>和 <code>Shenandoah</code>的实现思路又是差异显著的，如果说<code>RedHat公司</code>开发的<code>Shenandoah</code>像是<code>Oracle</code>的<code>G1收集器</code>的实际继承者的话，那Oracle公司开发的<code>ZGC</code>就更像是<code>Azul System公司</code>独步天下的<code>PGC</code>(Pauseless GC)和<code>C4</code>(Concurrent Continuously Compacting Collector)收集器的同胞兄弟。</p><p>与<code>Shenandoah</code>和<code>G1</code>一样，<code>ZGC</code>也采用基于<code>Region</code>的堆内存布局，但与它们不同的是，<code>ZGC</code>的<code>Region</code>具有<code>动态性</code>—-动态创建和销毁，以及<code>动态的区域容量大小</code>。在x64硬件平台下，ZGC的Region可以具有<code>大</code>、<code>中</code>、<code>小</code>三类容量：</p><ul><li>小型Region(SmallRegion)：容量固定为<code>2MB</code>，用于放置<code>小于256KB</code>的小对象。</li><li>中型Region(Medium Region)：容量固定为<code>32MB</code>，用于放置<code>大于等于256KB但小于4MB</code>的对象。</li><li>大型Region(Large Region)：容量不固定，可以动态变化，但必须为<code>2MB的整数倍</code>，用于放置<code>4MB或以上</code>的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于<code>中型Region</code>，最小容量可低至<code>4MB</code>。大型Region在ZGC的实现中是不会被<code>重分配</code>(重分配是ZGC的一种处理动作，用于复制对象的收集器阶段)的，因为复制一个大对象的代价非常高昂。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ZGC-Heap.png"><div class="caption"><b class="center-caption">ZGC的堆内存布局</b></div></li></ul><p>ZGC收集器有一个标志性的设计是它采用的<code>染色指针技术</code>(Colored Pointer)，以下为<code>ChatGPT</code>关于<code>染色指针技术</code>的回答，仅供参考。<br><pre class="line-numbers language-none"><code class="language-none">基本原理：

染色指针：在64位的JVM中，通常使用最后几位（如1～3位）的指针标记位作为染色指针。这些指针位用于标记对象的颜色信息。

对象颜色：每个对象都有一个颜色，可以是白色、灰色或黑色。
  白色：表示对象不可达，即尚未标记为垃圾。
  灰色：表示对象已经被标记为垃圾，但与其相关的其他对象还未进行标记。
  黑色：表示对象及其相关对象都已经标记为垃圾。

染色指针的应用：
  并发标记：在并发标记阶段，ZGC会从根对象开始标记，将灰色对象变为黑色对象，并遍历其引用的其他对象进行标记。染色指针用于标记哪些对象已经在并发标记过程中被标记为灰色。
  安全点判断：由于并发标记过程中应用程序可能持续运行，需要判断在何时进行安全点停顿以处理染色指针的变化。ZGC通过使用屏障插入点来探测染色指针的变化，并在需要时进行安全点停顿和处理。

优点：
  减少停顿时间：通过使用染色指针，ZGC可以实现并发标记，减少了垃圾收集对应用程序的停顿时间。
  高效的对象标记：染色指针使得并发标记过程更加高效，避免了不必要的重复标记操作。
  空间效率高：由于染色指针仅占用指针的几位，节省了额外的内存空间。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/Colored-Pointer.png"></p><div class="caption"><b class="center-caption">染色指针示意图</b></div><p></p><ul><li><p>染色指针的三大优势：</p><ul><li>可以使得一旦某个<code>Region</code>的存活对象被移走之后，这个<code>Region</code>立即就能够<code>被释放和重用掉</code>，而不必等待整个<code>堆</code>中所有指向该<code>Region</code>的引用都被修正后才能清理。</li><li>可以大幅减少在垃圾收集过程中<code>内存屏障</code>的使用数量，设置内存屏障，尤其是<code>写屏障</code>的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>可以作为一种可扩展的存储结构用来记录更多与<code>对象标记</code>、<code>重定位过程</code>相关的数据，以便日后进一步提高性能。</li></ul></li><li><p>ZGC的运作过程：</p><ul><li>并发标记(Concurrent Mark)：与<code>G1</code>、<code>Shenandoah</code>不同的是，<code>ZGC</code>的标记是<strong>在指针上</strong>而不是在对象上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li><li>并发预备重分配(Concurrent Prepare for Relocate)：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集</code>(Relocation Set)。</li><li>并发重分配(Concurrent Relocate)：重分配是ZGC执行过程中的<code>核心阶段</code>，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表</code>(Forward Table)，记录从旧对象到新对象的转向关系。</li><li>并发重映射(Concurrent Remap)：修正整个堆中指向<code>重分配集</code>中旧对象的<code>所有引用</code>。<img src="https://gcore.jsdelivr.net/gh/zyxelva/picgo/markdown/ZGC.png"><div class="caption"><b class="center-caption">ZGC垃圾收集器运行示意图</b></div></li></ul></li></ul><h2 id="4-6-Epsilon收集器"><a href="#4-6-Epsilon收集器" class="headerlink" title="4.6 Epsilon收集器"></a>4.6 Epsilon收集器</h2><p>以<strong>不能够</strong>进行垃圾收集为“卖点”的垃圾收集器（改名叫<code>自动内存管理子系统</code>最妥了）。由 <code>RedHat</code> 推出，它还要负责<code>堆的管理与布局</code>、<code>对象的分配</code>、<code>与解释器的协作</code>、<code>与编译器的协作</code>、<code>与监控子系统协作</code>等职责，主要用于需要剥离垃圾收集器影响的性能测试和压力测试。</p><h2 id="4-7-垃圾收集器整理"><a href="#4-7-垃圾收集器整理" class="headerlink" title="4.7 垃圾收集器整理"></a>4.7 垃圾收集器整理</h2><div class="table-container"><table><thead><tr><th>收集器</th><th>收集对象和算法</th><th>收集器类型</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>新生代，复制算法</td><td>单线程</td><td></td><td>简单高效。适用内存不大的情况</td></tr><tr><td>ParNew</td><td>新生代，复制算法</td><td>并行的多线程收集器</td><td>是<code>Serial</code>的多线程版本</td><td>搭配<code>CMS</code>的首选</td></tr><tr><td>Parallel Scavenge</td><td>新生代，复制算法</td><td>并行的多线程收集器</td><td>类似<code>ParNew</code>，更加关注吞吐量，达到可控的吞吐</td><td>本身是<code>server</code>级别的多CPU机器上的首选<code>GC</code>，适合后台运算不需要太多交互的任务</td></tr><tr><td>Serial Old</td><td>老年代，标记-整理算法</td><td>单线程</td><td></td><td>Client模式下的虚拟机使用</td></tr><tr><td>Parallel Old</td><td>老年代，标记-整理算法</td><td>并行的多线程收集器</td><td><code>Parallel Scavenge</code>的老年代版本，为了配合<code>Parallel Scavenge</code>面向吞吐量特性而开发的对应组合</td><td>在注重吞吐量和CPU资源敏感的场景使用</td></tr><tr><td>CMS</td><td>老年代，标记-清理算法</td><td>并行、并发收集器</td><td>尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：1）内存碎片；2）需要更多 cpu 资源；3）浮动垃圾问题，需要更大的堆空间</td><td>重视服务的<code>响应速度</code>、<code>系统停顿时间</code>和<code>用户体验</code>的互联网网站或者 <code>B/S</code> 系统。互联网后端目前<code>CMS</code>是主流的垃圾收集器</td></tr><tr><td>G1</td><td>跨新生代和老年代；标记-整理 + 化整为零</td><td>并行、并发收集器</td><td><code>JDK1.7</code> 才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成<code>低停顿</code>的内存回收；可预测的停顿是其最大的优势</td><td>面向服务端应用的垃圾收集器，目标为取代<code>CMS</code></td></tr><tr><td>Shenandoah</td><td>按Region，无分代一说；标记-清理-回收-引用更新</td><td>并发收集器</td><td><code>G1</code>升级款，非<code>Oracle</code>亲生，支持并发回收是与Hotspot垃圾收集器最大不同</td><td>可替代<code>G1</code></td></tr><tr><td>ZGC</td><td>按Region，无分代一说；标记-整理算法</td><td>并发收集器</td><td>动态Region、染色指针技术、支持“NUMA-Aware”的内存分配</td><td>以后的主流垃圾收集器，真正的低停顿</td></tr></tbody></table></div><h1 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5 内存分配与回收策略"></a>5 内存分配与回收策略</h1><h2 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a>5.1 对象优先在Eden分配</h2><p>大多数情况下，对象在新生代 <code>Eden 区</code>中分配。当 <code>Eden 区</code>没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。</p><blockquote><p>Tips：<br>新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。<br>老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。<br>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。<br>整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。</p><p>总结一下有哪些情况可能会触发JVM进行<code>Full GC</code>。</p><ul><li><code>System.gc()</code>方法的调用：此方法的调用是建议JVM进行<code>Full GC</code>，注意这只是建议而非一定，但在很多情况下它会触发<code>Full GC</code>，从而增加<code>Full GC</code>的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过<code>-XX:+DisableExplicitGC</code>来禁止调用<code>System.gc()</code>。</li><li>老年代空间不足：老年代空间不足会触发<code>Full GC</code>操作，若进行该操作后空间依然不足，则会抛出如下错误：<code>java.lang.OutOfMemoryError: Java heap space</code>。</li><li>永久代空间不足：JVM规范中运行时数据区域中的<code>方法区</code>，在<code>HotSpot虚拟机</code>中也称为<code>永久代</code>(Permanent Generation)，存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发<code>Full GC</code>。如果经过<code>Full GC</code>仍然回收不了，那么JVM会抛出如下错误信息：<code>java.lang.OutOfMemoryError: PermGen space</code></li><li>CMS GC 时出现<code>promotion failed</code>和<code>concurrent mode failure</code>：<code>promotion failed</code>，就是上文所说的<code>担保失败</code>，而<code>concurrent mode failure</code>是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</li><li>统计得到的<code>Minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间。</li></ul></blockquote><h2 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h2><p><code>大对象</code>就是指需要<strong>大量连续</strong>内存空间的Java对象，如<code>长字符串</code>、<code>数量庞大的数组</code>。</p><p>一个大对象能够存入 <code>Eden 区</code>的概率比较小，发生<code>分配担保</code>的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p><p>参数设置：<code>-XX:PretenureSizeThreshold</code>。</p><h2 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a>5.3 长期存活的对象将进入老年代</h2><p>还记得<code>对象头</code>的结构吗？对的，就是那个<code>分代年龄</code>。JVM给每个对象定义了一个<code>对象年龄计数器</code>。当新生代发生一次 <code>Minor GC</code> 后，存活下来的对象<code>年龄 +1</code>，当年龄超过一定值时，就将超过该值的所有对象转移到<code>老年代</code>中去。</p><p>参数设置：<code>-XX:M axTenuringThreshold</code>，默认值<code>15</code>。</p><h2 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h2><p>为了能更好地适应不同程序的内存状况，<code>HotSpot虚拟机</code>并不是永远要求对象的年龄必须达到<code>-XX:MaxTenuringThreshold</code>才能晋升老年代，如果在<code>Survivor</code>空间中<code>相同年龄</code><strong>所有对象</strong>大小的总和大于<code>Survivor</code>空间的<code>一半</code>，<code>年龄大于或等于该年龄的对象</code>就可以直接进入<code>老年代</code>，无须等到<code>-XX:MaxTenuringThreshold</code>中要求的年龄。</p><h2 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a>5.5 空间分配担保</h2><p><code>JDK 6 Update 24 之前</code>的规则是这样的：</p><blockquote><p>在发生 <code>Minor GC</code> 之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，</p><ul><li>如果这个条件成立，<code>Minor GC</code>可以确保是<code>安全的</code>；</li><li>如果不成立，则虚拟机会查看 <code>HandlePromotionFailure</code> 值是否设置为允许担保失败，<ul><li>如果否，<code>Full GC</code>；</li><li>如果是，那么会继续检查<strong>老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</strong>，<ul><li>如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li><li>如果小于，那此时也要改为进行一次<code>Full GC</code>。</li></ul></li></ul></li></ul></blockquote><p><code>JDK 6 Update 24 之后</code>的规则变为：</p><blockquote><p>只要<strong>老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>，就会进行<code>Minor GC</code>，否则将进行<code>Full GC</code>。</p></blockquote><p>通过清除<code>老年代</code>中废弃数据来扩大老年代空闲空间，以便给新生代作担保。这个过程就是<code>分配担保</code>。</p><h2 id="5-6-本地线程分配缓冲-TLAB"><a href="#5-6-本地线程分配缓冲-TLAB" class="headerlink" title="5.6 本地线程分配缓冲(TLAB)"></a>5.6 本地线程分配缓冲(TLAB)</h2><p>把内存分配的动作按照<code>线程</code>划分在不同的空间之中进行，即每个线程在<code>Java 堆</code>中<strong>预先分配</strong>一小块私有内存，也就是<code>本地线程分配缓冲</code>(Thread Local Allocation Buffer，<code>TLAB</code>)，JVM在线程初始化时，同时也会申请一块指定大小的内存，只给<code>当前线程</code>使用，这样每个线程都单独拥有一个<code>Buffer</code>，如果需要分配内存，就在自己的<code>Buffer</code>上分配，这样就不存在竞争的情况，可以大大提升分配效率，当<code>Buffer</code>容量不够的时候，再重新从<code>Eden 区域</code>申请一块继续使用。</p><p><code>TLAB的目的</code>是在为<code>新对象</code>分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。<code>TLAB</code>只是让每个线程有<code>私有的分配指针</code>，但底下存对象的内存空间还是可以被所有线程访问的，只是其它线程无法在这个区域分配而已。当一个<code>TLAB</code>用满(分配指针<code>top</code>撞上分配极限<code>end</code>了)，就新申请一个<code>TLAB</code>。</p><p>设置参数：<code>-XX:+UseTLAB</code>，允许在<code>年轻代空间</code>中使用<code>TLAB</code>。默认情况下<code>启用</code>此选项。要禁用<code>TLAB</code>，请指定<code>-XX:-UseTLAB</code>。</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Kezade</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://zyxelva.github.io/posts/1688993497.html">https://zyxelva.github.io/posts/1688993497.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Kezade</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span></a> <a href="/tags/GC%E7%AE%97%E6%B3%95/"><span class="chip bg-color">GC算法</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.twikoo-card{margin:1.5rem auto}.twikoo-card .card-content{padding:20px}#tcomments textarea{box-sizing:border-box;background:url("/") 100% 100% no-repeat}#tcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem;text-align:left}#tcomments blockquote p{text-indent:.2rem}#tcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#tcomments img{max-width:100%;height:auto;cursor:pointer}#tcomments ol li{list-style-type:decimal}#tcomments ol,ul{display:block;padding-left:2em;word-spacing:0.05rem}#tcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#tcomments ul li{list-style-type:disc}#tcomments ul ul li{list-style-type:circle}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#tcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#tcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#tcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#tcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#tcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#tcomments h6{font-size:1rem;line-height:1.3rem}#tcomments p{font-size:1rem;line-height:1.5rem}#tcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#tcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#tcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#tcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#tcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#tcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#tcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#tcomments b,strong{font-weight:700}#tcomments dfn{font-style:italic}#tcomments small{font-size:85%}#tcomments cite{font-style:normal}#tcomments mark{background-color:#fcf8e3;padding:.2em}#tcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#tcomments table th{background-color:#f2f2f2;min-width:80px}#tcomments table td{min-width:80px}#tcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card twikoo-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div class="card-content" style="display:grid"><div id="tcomments"></div></div></div><script src="https://gcore.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js"></script><script>twikoo.init({envId:"https://kezadetwikoo.netlify.app/.netlify/functions/twikoo",el:"#tcomments",region:"",path:""}).then(function(){for(var t=document.querySelector("#twikoo").getElementsByTagName("input"),e=0;e<t.length;e++)t[e]&&t[e].classList.add("browser-default")})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/514811746.html"><div class="card-image"><img src="/medias/JVM.png" class="responsive-img" alt="【JVM学习】5.HostSpot的细节"> <span class="card-title">【JVM学习】5.HostSpot的细节</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-06-30</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" class="post-category">JVM学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span></a> <a href="/tags/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/"><span class="chip bg-color">三色标记</span></a> <a href="/tags/%E5%AE%89%E5%85%A8%E7%82%B9/"><span class="chip bg-color">安全点</span></a> <a href="/tags/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8/"><span class="chip bg-color">跨代引用</span></a> <a href="/tags/%E5%86%99%E5%B1%8F%E9%9A%9C/"><span class="chip bg-color">写屏障</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/1942558204.html"><div class="card-image"><img src="/medias/JVM.png" class="responsive-img" alt="【JVM学习】3.JVM中的对象"> <span class="card-title">【JVM学习】3.JVM中的对象</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-06-27</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" class="post-category">JVM学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/JVM/"><span class="chip bg-color">JVM</span></a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="chip bg-color">类加载</span></a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="chip bg-color">内存分配</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("120"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: Kezade<br />文章作者: Kezade<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeBlockFuction.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/prism/prism.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeLang.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeCopy.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h1, h2, h3, h4, h5"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const o="expanded";let n=$("#toc-aside"),i=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){n.hasClass(o)?(n.removeClass(o).hide(),i.removeClass("l9")):(n.addClass(o).show(),i.addClass("l9")),function(t,e){let o=$("#"+t);if(0===o.length)return;let n=o.width();n+=n>=450?21:n>=350&&n<450?18:n>=300&&n<350?16:14,$("#"+e).width(n)}("artDetail","prenext-posts")})})</script></main><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019-2025</span> <a href="/about" target="_blank">Kezade</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=6e4,t=36e5,n=864e5,a=365*n,i=new Date,r="2019",o=i.getFullYear(),s=i.getMonth()+1,l=i.getDate(),m=i.getHours(),c=i.getMinutes(),d=i.getSeconds(),g=Date.UTC(r,"6","28","0","0","0"),h=Date.UTC(o,s,l,m,c,d)-g,u=Math.floor(h/a),M=Math.floor(h/n-365*u),T=Math.floor((h-(365*u+M)*n)/t),f=Math.floor((h-(365*u+M)*n-T*t)/e),y=Math.floor((h-(365*u+M)*n-T*t-f*e)/1e3);if(r===String(o)){document.getElementById("year").innerHTML=o;var v="This site has been running for "+M+" days";v="本站已运行 "+M+" 天",document.getElementById("sitetime").innerHTML=v}else{document.getElementById("year").innerHTML=r+" - "+o;var H="This site has been running for "+u+" years and "+M+" days "+T+" hours "+f+" mins "+y+" seconds";H="本站已苟且偷生 "+u+" 年 "+M+" 天 "+T+" 小时 "+f+" 分钟 "+y+" 秒",document.getElementById("sitetime").innerHTML=H}};calcSiteTime(),setInterval(calcSiteTime,1e3)</script><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/zyxelva" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:zyxelva@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1807401971" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1807401971" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a> <a href="https://www.zhihu.com/people/kezade" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kezade" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="../rss2.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach(function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach(function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))}),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach(function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")}),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}}),t+="</ul>",s.innerHTML=t)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/materialize/materialize.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/masonry/masonry.pkgd.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/aos/aos.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/js/matery.js"></script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.css"><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/background/ribbon-dynamic.js" async></script><script src="https://gcore.jsdelivr.net/gh/zyxelva/zyxelva.github.io@main/libs/instantpage/instantpage.js" type="module"></script></body></html>